{"meta":{"title":"helloliangxw","subtitle":null,"description":null,"author":"liangxw","url":"http://yoursite.com"},"pages":[{"title":"","date":"2017-02-27T12:02:11.645Z","updated":"2017-02-27T12:02:11.645Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"博客创建于2017年1月。 激励自己做到以下几点： 多整理总结 多读书 多分享 有待完善！"},{"title":"tags","date":"2017-04-17T15:22:36.000Z","updated":"2017-04-17T15:26:07.812Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2017-04-17T15:23:32.000Z","updated":"2017-04-17T15:25:47.092Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Python模块-NumPy(3)","slug":"Python模块-NumPy(3)","date":"2017-04-17T12:36:00.000Z","updated":"2017-04-17T13:29:33.016Z","comments":true,"path":"2017/04/17/Python模块-NumPy(3)/","link":"","permalink":"http://yoursite.com/2017/04/17/Python模块-NumPy(3)/","excerpt":"","text":"随机函数 函数 说明 rand(d0,d1,..,dn) 根据d0‐dn创建随机数数组，浮点数，[0,1)，均匀分布 randn(d0,d1,..,dn) 根据d0‐dn创建随机数数组，标准正态分布 randint(low[,high,shape]) 根据shape创建随机整数或整数数组，范围是[low, high) seed(s) 随机数种子，s是给定的种子值 1234import numpy as npa = np.random.rand(3, 4)print(a) [[ 0.19114922 0.7068554 0.97088057 0.22036382] [ 0.55174823 0.00680082 0.73785489 0.88970624] [ 0.45998671 0.13359651 0.83150316 0.19457805]] 12b = np.random.randn(3, 4)print(b) [[ 1.12238235 0.27006584 0.63285753 1.08344082] [ 0.75890063 -0.41283425 1.20569367 -0.6684051 ] [-0.9419934 0.40069505 -0.78798551 1.60365521]] 12c = np.random.randint(3, 10, (2, 3))print(c) [[6 5 7] [8 4 8]] 12345678# 相同的种子，随机数的值相同np.random.seed(10)d = np.random.randint(3, 10, (2, 3))print(d)np.random.seed(10)e = np.random.randint(3, 10, (2, 3))print(e) [[4 8 7] [3 4 6]] [[4 8 7] [3 4 6]] 函数 说明 shuffle(a) 根据数组a的第1轴进行随排列，改变数组a permutation(a) 根据数组a的第1轴产生一个新的乱序数组，不改变数组a choice(a[,size,replace,p]) 从一维数组a中以概率p抽取元素，形成size形状新数组，replace表示是否可以重用元素，默认为False 12345# a改变a = np.arange(18).reshape(6, 3)print(a)np.random.shuffle(a)print(a) [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11] [12 13 14] [15 16 17]] [[15 16 17] [ 0 1 2] [ 3 4 5] [12 13 14] [ 6 7 8] [ 9 10 11]] 123456# a不改变a = np.arange(18).reshape(6, 3)print(a)b = np.random.permutation(a)print(a)print(b) [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11] [12 13 14] [15 16 17]] [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11] [12 13 14] [15 16 17]] [[ 0 1 2] [15 16 17] [ 6 7 8] [ 9 10 11] [ 3 4 5] [12 13 14]] 123a = np.arange(18)b = np.random.choice(a, (3, 4), True, p = a/np.sum(a))print(b) [[ 6 11 15 13] [ 7 16 6 9] [ 5 4 15 2]] 函数 说明 uniform(low,high,size) 产生具有均匀分布的数组,low起始值,high结束值,size形状 normal(loc,scale,size) 产生具有正态分布的数组,loc均值,scale标准差,size形状 poisson(lam,size) 产生具有泊松分布的数组,lam随机事件发生率,size形状 统计函数 函数 说明 sum(a, axis=None) 根据给定轴axis计算数组a相关元素之和，axis整数或元组 mean(a, axis=None) 根据给定轴axis计算数组a相关元素的期望，axis整数或元组 average(a,axis=None,weights=None) 根据给定轴axis计算数组a相关元素的加权平均值 std(a, axis=None) 根据给定轴axis计算数组a相关元素的标准差 var(a, axis=None) 根据给定轴axis计算数组a相关元素的方差 axis=None是统计函数的标配参数 12a = np.arange(15).reshape(3, 5)print(a) [[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14]] 1print(np.sum(a, axis=0)) [15 18 21 24 27] 1print(np.mean(a, axis=1)) [ 2. 7. 12.] 1234# axis = 0为列向# 以第2列为例# (1*10+6*5+11*1)/(10+5+1) = 3.1875print(np.average(a, axis = 0, weights = [10, 5, 1])) [ 2.1875 3.1875 4.1875 5.1875 6.1875] 1print(np.std(a), np.var(a)) 4.32049379894 18.6666666667 函数 说明 min(a) max(a) 计算数组a中元素的最小值、最大值 argmin(a) argmax(a) 计算数组a中元素最小值、最大值的降一维后下标 unravel_index(index, shape) 根据shape将一维下标index转换成多维下标 ptp(a) 计算数组a中元素最大值与最小值的差 median(a) 计算数组a中元素的中位数（中值） 12a = np.arange(15).reshape(3, 5)print(a) [[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14]] 1print(np.max(a), np.min(a, axis = 0)) 14 [0 1 2 3 4] 1print(np.argmin(a, axis = 0), np.argmax(a, axis = 1), np.argmax(a)) [0 0 0 0 0] [4 4 4] 14 1print(np.unravel_index([14], (3, 5))) (array([2], dtype=int64), array([4], dtype=int64)) 1print(np.ptp(a)) 14 1print(np.median(a)) 7.0 梯度函数 函数 说明 np.gradient(f) 计算数组f中元素的梯度，当f为多维时，返回每个维度梯度 梯度：连续值之间的变化率，即斜率。XY坐标系中，连续三个X坐标对应的Y轴值为a、b、c，那么b的梯度是：(c‐a)/2 对于[a, b, c, d]而言，a的梯度为：(b-a)/1b的梯度为：(c-a)/2c的梯度为：(d-b)/2d的梯度为：(d-c)/1 12a = np.random.randint(0, 20, (5))print(a) [11 10 9 15 18] 1print(np.gradient(a)) [-1. -1. 2.5 4.5 3. ] 12a = np.random.randint(0, 20, (3, 5))print(a) [[16 7 11 17 14] [ 7 11 1 0 12] [ 5 4 7 18 12]] 12# 结果分别表示，第0维的梯度和第1维的梯度print(np.gradient(a)) [array([[ -9. , 4. , -10. , -17. , -2. ], [ -5.5, -1.5, -2. , 0.5, -1. ], [ -2. , -7. , 6. , 18. , 0. ]]), array([[ -9. , -2.5, 5. , 1.5, -3. ], [ 4. , -3. , -5.5, 5.5, 12. ], [ -1. , 1. , 7. , 2.5, -6. ]])]","categories":[{"name":"Python模块","slug":"Python模块","permalink":"http://yoursite.com/categories/Python模块/"}],"tags":[{"name":"NumPy","slug":"NumPy","permalink":"http://yoursite.com/tags/NumPy/"}]},{"title":"Python模块-NumPy(2)","slug":"Python模块-NumPy(2)","date":"2017-04-17T12:07:00.000Z","updated":"2017-04-17T12:34:36.906Z","comments":true,"path":"2017/04/17/Python模块-NumPy(2)/","link":"","permalink":"http://yoursite.com/2017/04/17/Python模块-NumPy(2)/","excerpt":"","text":"一维和二维数据的存取保存1np.savetxt(fname, array, fmt='%.18e', delimiter=None) fname文件、字符串或产生器，可以是.gz或.bz2的压缩文件 array存入文件的数组 fmt写入文件的格式，例如：%d %.2f %.18e delimiter分割字符串，默认是任何空格 1234import numpy as npa = np.arange(100).reshape(5, 20)np.savetxt('a.csv', a, fmt='%d', delimiter=',') 读取1np.loadtxt(fname, dtype=np.float, delimiter=None, unpack=False) fname文件、字符串或产生器，可以是.gz或.bz2的压缩文件 dtype数据类型，可选 delimiter分割字符串，默认是任何空格 unpack如果True，每一列将分别写入不同变量 12b = np.loadtxt('a.csv', dtype = np.float, delimiter=',')print(b) [[ 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19.] [ 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39.] [ 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 58. 59.] [ 60. 61. 62. 63. 64. 65. 66. 67. 68. 69. 70. 71. 72. 73. 74. 75. 76. 77. 78. 79.] [ 80. 81. 82. 83. 84. 85. 86. 87. 88. 89. 90. 91. 92. 93. 94. 95. 96. 97. 98. 99.]] 12b = np.loadtxt('a.csv', dtype = np.float, delimiter=',', unpack=True)print(b) [[ 0. 20. 40. 60. 80.] [ 1. 21. 41. 61. 81.] [ 2. 22. 42. 62. 82.] [ 3. 23. 43. 63. 83.] [ 4. 24. 44. 64. 84.] [ 5. 25. 45. 65. 85.] [ 6. 26. 46. 66. 86.] [ 7. 27. 47. 67. 87.] [ 8. 28. 48. 68. 88.] [ 9. 29. 49. 69. 89.] [ 10. 30. 50. 70. 90.] [ 11. 31. 51. 71. 91.] [ 12. 32. 52. 72. 92.] [ 13. 33. 53. 73. 93.] [ 14. 34. 54. 74. 94.] [ 15. 35. 55. 75. 95.] [ 16. 36. 56. 76. 96.] [ 17. 37. 57. 77. 97.] [ 18. 38. 58. 78. 98.] [ 19. 39. 59. 79. 99.]] 多维数据的存取保存1a.tofile(fname, sep='', format='%s') fname文件、字符串 sep数据分割字符串，如果是空串，写入文件为二进制 format写入数据的格式 12a = np.arange(18).reshape(3, 6)a.tofile('a.dat', sep = '', format = '%d') 读取1np.fromfile(fname, dtype=float, count=-1, sep='') fname文件、字符串 dtype读取的数据类型 count读入元素个数，‐1表示读入整个文件 sep数据分割字符串，如果是空串，读入文件为二进制 12b = np.fromfile('a.dat', dtype = np.int32, sep = '')print(b) [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17] 注意：a.tofile()和np.fromfile()需要配合使用，并且需要知道存入文件时数组的维度和元素类型。可以通过元数据文件来存储额外信息。 便捷文件存取保存：1np.save(fname, array) 或 np.savez(fname, array) fname文件名，以.npy为扩展名，压缩扩展名为.npz array数组变量 读取:1np.load(fname) fname文件名，以.npy为扩展名，压缩扩展名为.npz 1234a = np.arange(18).reshape(3, 6)np.save('a.npy', a)b = np.load('a.npy')print(b) [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11] [12 13 14 15 16 17]] 如果我们用文本方式打开a.npy文件：1234揘UMPY\u0001 F &#123;&apos;descr&apos;: &apos;&lt;i4&apos;, &apos;fortran_order&apos;: False, &apos;shape&apos;: (3, 6), &#125; \u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \u0007 \b \u000e \u000f \u0010 \u0011 会发现，npy文件中保存了原来数组的大小和类型。","categories":[{"name":"Python模块","slug":"Python模块","permalink":"http://yoursite.com/categories/Python模块/"}],"tags":[{"name":"NumPy","slug":"NumPy","permalink":"http://yoursite.com/tags/NumPy/"}]},{"title":"Python模块-NumPy(1)","slug":"Python模块-NumPy(1)","date":"2017-04-17T11:27:00.000Z","updated":"2017-04-17T12:25:39.491Z","comments":true,"path":"2017/04/17/Python模块-NumPy(1)/","link":"","permalink":"http://yoursite.com/2017/04/17/Python模块-NumPy(1)/","excerpt":"","text":"N维数组对象ndarrayndarray对象的属性 属性 说明 .ndim 维度的数量 .shape ndarray对象的尺度，对于矩阵，n行m列 .size ndarray对象元素的个数，相当于.shape中n*m的值 .dtype ndarray对象的元素类型 .itemsize ndarray对象中每个元素的大小，以字节为单位 12345import numpy as np a = np.array([ [1, 2, 3], [4, 5, 6] ] )print(a)print(a.ndim, a.shape, a.size, a.dtype, a.itemsize) [[1 2 3] [4 5 6]] 2 (2, 3) 6 int32 4 元素类型 数据类型 说明 bool 布尔类型，True或False intc 与C语言中的int类型一致，一般是int32或int64 intp 用于索引的整数，与C语言中ssize_t一致，int32或int64 int8 字节长度的整数，取值：[‐128, 127] int16 16位长度的整数，取值：[‐32768, 32767] int32 32位长度的整数，取值：[‐2 31 , 2 31 ‐1] int64 64位长度的整数，取值：[‐2 63 , 2 63 ‐1] uint8 8位无符号整数，取值：[0, 255] uint16 16位无符号整数，取值：[0, 65535] uint32 32位无符号整数，取值：[0, 2 32 ‐1] uint64 32位无符号整数，取值：[0, 2 64 ‐1] float16 16位半精度浮点数：1位符号位，5位指数，10位尾数，(符号)尾数 \\(*10^{指数}\\) float32 32位半精度浮点数：1位符号位，8位指数，23位尾数 float64 64位半精度浮点数：1位符号位，11位指数，52位尾数 complex64 复数类型，实部和虚部都是32位浮点数 complex128 复数类型，实部和虚部都是64位浮点数 ndarray为什么要支持这么多种元素类型？ 科学计算涉及数据较多，对存储和性能都有较高要求 对元素类型精细定义，有助于NumPy合理使用存储空间并优化性能 对元素类型精细定义，有助于程序员对程序规模进行合理评估 ndarray的创建通过列表、元组等创建1234567a = np.array([1, 2, 3])# 列表和元组可以共同使用，只需要元素个数相同b = np.array([ [1, 2], (3, 4) ])c = np.array([20, 21], dtype = np.float)print(a, a.dtype)print(b, b.dtype)print(c, c.dtype) [1 2 3] int32 [[1 2] [3 4]] int32 [ 20. 21.] float64 当np.array()不指定dtype时，NumPy将根据数据情况关联一个dtype类型。 通过NumPy函数创建 函数 说明 np.arange(n) 类似range()函数，返回ndarray类型，元素从0到n‐1 np.ones(shape) 根据shape生成一个全1数组，shape是元组类型 np.zeros(shape) 根据shape生成一个全0数组，shape是元组类型 np.full(shape,val) 根据shape生成一个数组，每个元素值都是val np.eye(n) 创建一个正方的n*n单位矩阵，对角线为1，其余为0 12a = np.arange(12)print(a) [ 0 1 2 3 4 5 6 7 8 9 10 11] 12a = np.ones((2, 3))print(a) [[ 1. 1. 1.] [ 1. 1. 1.]] 12a = np.zeros((2, 3))print(a) [[ 0. 0. 0.] [ 0. 0. 0.]] 12a = np.full((2, 3), 21, dtype = np.float)print(a) [[ 21. 21. 21.] [ 21. 21. 21.]] 12a = np.eye(4)print(a) [[ 1. 0. 0. 0.] [ 0. 1. 0. 0.] [ 0. 0. 1. 0.] [ 0. 0. 0. 1.]] 函数 说明 np.linspace(start, end, n) 根据起止数据等间距地填充数据，形成长度为n的数组 np.concatenate((a, b)) 将两个或多个数组合并成一个新的数组 123# 每个元素之间的间距为(end-start)/(n-1)a = np.linspace(1, 10, 4)print(a) [ 1. 4. 7. 10.] 1234# endpoint为False时，表示end不在最后生成的数组中# 每个元素之间的间距为(end-start)/nb = np.linspace(1, 10, 4, endpoint = False)print(b) [ 1. 3.25 5.5 7.75] 12c = np.concatenate((a, b))print(c) [ 1. 4. 7. 10. 1. 2.75 4.5 6.25] 函数 说明 np.ones_like(a) 根据数组a的形状生成一个全1数组 np.zeros_like(a) 根据数组a的形状生成一个全0数组 np.full_like(a,val) 根据数组a的形状生成一个数组，每个元素值都是val 12a = np.ones((4, 4))print(a.shape) (4, 4) 12b = np.ones_like(a)print(b) [[ 1. 1. 1. 1.] [ 1. 1. 1. 1.] [ 1. 1. 1. 1.] [ 1. 1. 1. 1.]] 12b = np.zeros_like(a)print(b) [[ 0. 0. 0. 0.] [ 0. 0. 0. 0.] [ 0. 0. 0. 0.] [ 0. 0. 0. 0.]] 12b = np.full_like(a, 6)print(b) [[ 6. 6. 6. 6.] [ 6. 6. 6. 6.] [ 6. 6. 6. 6.] [ 6. 6. 6. 6.]] 通过复制已有数组1234a = np.arange(5)b = ac = a.view()d = a.copy() 区别： b = ab和a完全一样，改变b时a也跟着改变，是完全相同的对象 c = a.view()c是a的浅复制，c和a是不同的对象，但是改变c时a也跟着改变 d = a.copy()d是a的深复制，改变d时a不改变。推荐使用。 ndarray数组的变换维度变换 方法 说明 .reshape(shape) 不改变数组元素，返回一个shape形状的数组，原数组不变 .resize(shape) 与.reshape()功能一致，但修改原数组 .swapaxes(ax1,ax2) 将数组n个维度中两个维度进行调换 .flatten() .ravel() 对数组进行降维，返回折叠后的一维数组，原数组不变 .T 转置 123456# 三维数组，为层*行*列a = np.array([ [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]], [[4, 4, 4, 4], [5, 5, 5, 5], [6, 6, 6, 6]] ], dtype = np.int32)print(a) [[[1 1 1 1] [2 2 2 2] [3 3 3 3]] [[4 4 4 4] [5 5 5 5] [6 6 6 6]]] 123b = a.reshape((3, 8))print(b)print(a) [[1 1 1 1 2 2 2 2] [3 3 3 3 4 4 4 4] [5 5 5 5 6 6 6 6]] [[[1 1 1 1] [2 2 2 2] [3 3 3 3]] [[4 4 4 4] [5 5 5 5] [6 6 6 6]]] 12345# 修改原数组a.resize((3, 8))print(a)a.shape = (4, 6)print(a) [[1 1 1 1 2 2 2 2] [3 3 3 3 4 4 4 4] [5 5 5 5 6 6 6 6]] [[1 1 1 1 2 2] [2 2 3 3 3 3] [4 4 4 4 5 5] [5 5 6 6 6 6]] 12b = a.flatten()print(b) [1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6] 12b = a.ravel()print(b) [1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6] 12b = a.Tprint(b) [[1 2 4 5] [1 2 4 5] [1 3 4 6] [1 3 4 6] [2 3 5 6] [2 3 5 6]] 元素类型变换1print(a.dtype) int32 1234# astype()方法一定会创建新的数组（原始数据的一个拷贝），即使两个类型一致b = a.astype(np.float)print(b)print(b.dtype) [[ 1. 1. 1. 1. 2. 2. 2. 2.] [ 3. 3. 3. 3. 4. 4. 4. 4.] [ 5. 5. 5. 5. 6. 6. 6. 6.]] float64 向列表的转换1print(a) [[1 1 1 1 2 2 2 2] [3 3 3 3 4 4 4 4] [5 5 5 5 6 6 6 6]] 12print(a.tolist())print(type(a)) [[1, 1, 1, 1, 2, 2, 2, 2], [3, 3, 3, 3, 4, 4, 4, 4], [5, 5, 5, 5, 6, 6, 6, 6]] &lt;class &apos;numpy.ndarray&apos;&gt; ndarray数组的索引与切片 索引获取数组中特定位置元素的过程 切片获取数组元素子集的过程 一维数组12a = np.linspace(0, 51, 18)print(a) [ 0. 3. 6. 9. 12. 15. 18. 21. 24. 27. 30. 33. 36. 39. 42. 45. 48. 51.] 12print(a[2])print(a[-2]) 6.0 48.0 1234# 起始编号:终止编号(不含):步长print(a[0:6:2])print(a[10:2:-2])print(a[::3]) [ 0. 6. 12.] [ 30. 24. 18. 12.] [ 0. 9. 18. 27. 36. 45.] 多维数组12a = np.arange(24).reshape((2, 3, 4))print(a) [[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[12 13 14 15] [16 17 18 19] [20 21 22 23]]] 12print(a[1, 2, 3])print(a[-2, 2, -3]) 23 9 1print(a[:, 1, 3]) [ 7 19] 1print(a[:, 1:3, 3]) [[ 7 11] [19 23]] 1print(a[:, 1:3, :]) [[[ 4 5 6 7] [ 8 9 10 11]] [[16 17 18 19] [20 21 22 23]]] 1print(a[:, :, ::2]) [[[ 0 2] [ 4 6] [ 8 10]] [[12 14] [16 18] [20 22]]] ndarray数组的运算NumPy一元函数 函数 说明 np.abs(x) np.fabs(x) 计算数组各元素的绝对值 np.sqrt(x) 计算数组各元素的平方根 np.square(x) 计算数组各元素的平方 np.log(x) np.log10(x) np.log2(x) 计算数组各元素以e为底、以10为底、以2为底的对数 np.ceil(x) np.floor(x) 计算数组各元素的ceiling值 或 floor值 np.rint(x) 计算数组各元素的四舍五入值 np.modf(x) 将数组各元素的小数和整数部分以两个独立数组形式返回 np.cos(x) np.sin(x) np.tan(x) 计算数组各元素的三角函数 np.exp(x) 计算数组各元素的指数值 np.sign(x) 计算数组各元素的符号值，1(+), 0, ‐1(‐) np.sort(x) 对数组进行排序 np.tile(x, (m, n)) 将数组复制成(m,n)份 12345import numpy as npa = np.arange(4).reshape(2, 2)b = np.arange(4, 0, -1).reshape(2, 2)print(a)print(b) [[0 1] [2 3]] [[4 3] [2 1]] 1print(a/2) [[ 0. 0.5] [ 1. 1.5]] 1print(np.sort(b, axis = 0)) [[2 1] [4 3]] 1print(np.tile(a, (2, 2))) [[0 1 0 1] [2 3 2 3] [0 1 0 1] [2 3 2 3]] NumPy二元函数 函数 说明 + ‐ * / ** 两个数组各元素进行对应运算 np.dot(x,y) 矩阵相乘，即x.dot(y) np.maximum(x,y) np.minimum(x,y) 元素级的最大值/最小值计算 np.fmax(x,y) np.fmin(x,y) 同上 np.mod(x,y) 元素级的模运算 np.copysign(x,y) 将数组y中各元素值的符号赋值给数组x对应元素 &gt;, &lt;, &gt;=, &lt;=, ==, != 算术比较，产生布尔型数组 np.vstack((a,b)) np.hstack((a,b)) 数组拼接 np.hsplit(a,n) np.vsplit(a,n) 将数组平均切成n份 12345import numpy as npa = np.arange(4).reshape(2, 2)b = np.arange(4, 0, -1).reshape(2, 2)print(a)print(b) [[0 1] [2 3]] [[4 3] [2 1]] 1print(np.dot(a, b)) [[ 2 1] [14 9]] 12print(np.maximum(a, b))print(np.fmax(a, b)) [[4 3] [2 3]] [[4 3] [2 3]] 1print(np.mod(a, b)) [[0 1] [0 0]] 12print(np.hstack((a, b)))print(np.vstack((a, b))) [[0 1 4 3] [2 3 2 1]] [[0 1] [2 3] [4 3] [2 1]] 12a = np.arange(24).reshape(2, 12)print(a) [[ 0 1 2 3 4 5 6 7 8 9 10 11] [12 13 14 15 16 17 18 19 20 21 22 23]] 12# 将a平均切割成4份print(np.hsplit(a, 4)) [array([[ 0, 1, 2], [12, 13, 14]]), array([[ 3, 4, 5], [15, 16, 17]]), array([[ 6, 7, 8], [18, 19, 20]]), array([[ 9, 10, 11], [21, 22, 23]])] 12# 在第2列和第5列之前分别切一刀print(np.hsplit(a, (2, 5))) [array([[ 0, 1], [12, 13]]), array([[ 2, 3, 4], [14, 15, 16]]), array([[ 5, 6, 7, 8, 9, 10, 11], [17, 18, 19, 20, 21, 22, 23]])] ndarray方法 方法 说明 .argsort() 排序后的下标索引 .argmax() .argmin() 最大值和最小值的下标索引 12345a = np.array([2, 5, 6, 2, 3])print(a)print(a.argmax())print(a.argmin())print(a.argsort()) [2 5 6 2 3] 2 0 [0 3 4 1 2]","categories":[{"name":"Python模块","slug":"Python模块","permalink":"http://yoursite.com/categories/Python模块/"}],"tags":[{"name":"NumPy","slug":"NumPy","permalink":"http://yoursite.com/tags/NumPy/"}]}]}