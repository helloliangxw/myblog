{"meta":{"title":"helloliangxw","subtitle":null,"description":null,"author":"liangxw","url":"http://helloliangxw.com"},"pages":[{"title":"","date":"2017-04-17T15:41:57.071Z","updated":"2017-04-17T15:41:57.071Z","comments":true,"path":"404.html","permalink":"http://helloliangxw.com/404.html","excerpt":"","text":""},{"title":"","date":"2017-02-27T12:02:11.645Z","updated":"2017-02-27T12:02:11.645Z","comments":true,"path":"about/index.html","permalink":"http://helloliangxw.com/about/index.html","excerpt":"","text":"博客创建于2017年1月。 激励自己做到以下几点： 多整理总结 多读书 多分享 有待完善！"},{"title":"分类","date":"2017-04-17T15:23:32.000Z","updated":"2017-04-21T15:38:23.567Z","comments":false,"path":"categories/index.html","permalink":"http://helloliangxw.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2017-04-21T15:37:03.000Z","updated":"2017-04-21T15:38:28.970Z","comments":false,"path":"tags/index.html","permalink":"http://helloliangxw.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Matplotlib.pyplot入门","slug":"Matplotlib.pyplot入门","date":"2017-04-22T05:12:00.000Z","updated":"2017-04-22T08:49:43.578Z","comments":true,"path":"2017/04/22/Matplotlib.pyplot入门/","link":"","permalink":"http://helloliangxw.com/2017/04/22/Matplotlib.pyplot入门/","excerpt":"","text":"Malplotlib图库Matplotlib图库 调用方式12import matplotlib.pyplot as pltplt.plot(x, y, format_string, **kwargs) x X轴数据，列表或数组，可选 y Y轴数据，列表或数组 format_string 控制曲线的格式字符串，可选 **kwargs 第二组或更多(x,y,format_string) 12%config InlineBackend.figure_format='svg'%matplotlib inline 123456import matplotlib.pyplot as pltimport numpy as npimport pylab as pla = np.arange(10)plt.plot(a, a*1.5, a, a*2, a, a*3, a, a*4);#plt.show() format_stringformat_string是控制曲线的格式字符串，可选参数。 曲线的格式由三部分组成： 颜色字符 风格字符 标记字符 颜色字符 颜色字符 说明 颜色字符 说明 ‘b’ 蓝色 ‘m’ 洋红色 magenta ‘g’ 绿色 ‘y’ 黄色 ‘r’ 红色 ‘k’ 黑色 ‘c’ 青绿色 cyan ‘w’ 白色 ‘#008000’ RGB某颜色 ‘0.8’ 灰度值字符串 风格字符 风格字符 说明 ‘‐’ 实线 ‘‐‐’ 破折线 ‘‐.’ 点划线 ‘:’ 虚线 ‘’ ‘ ‘ 无线条 标记字符 标记字符 说明 标记字符 说明 标记字符 说明 ‘.’ 点标记 ‘1’ 下花三角标记 ‘h’ 竖六边形标记 ‘,’ 像素标记(极小点) ‘2’ 上花三角标记 ‘H’ 横六边形标记 ‘o’ 实心圈标记 ‘3’ 左花三角标记 ‘+’ 十字标记 ‘v’ 倒三角标记 ‘4’ 右花三角标记 ‘x’ x标记 ‘^’ 上三角标记 ‘s’ 实心方形标记 ‘D’ 菱形标记 ‘&gt;’ 右三角标记 ‘p’ 实心五角标记 ‘d’ 瘦菱形标记 ‘&lt;’ 左三角标记 ‘*‘ 星形标记 &#124; 垂直线标记 123a = np.arange(10)plt.plot(a, a*1.5, 'go-', a, a*2,'r&gt;', a, a*3, '*', a, a*4, 'b-.')plt.show() **kwargs 关键字 说明 color=’green’ 控制颜色 linestyle=’dashed’ 线条风格 marker=’o’ 标记风格 markerfacecolor=’blue’ 标记颜色 markersize=20 标记尺寸 … … 中文显示rcParams 属性 说明 ‘font.family’ 用于显示字体的名字 ‘font.style’ 字体风格，正常’normal’或 斜体’italic’ ‘font.size’ 字体大小，整数字号或者’large’、’x‐small’ 中文字体种类： 中文字体 说明 ‘SimHei’ 中文黑体 ‘Kaiti’ 中文楷体 ‘LiSu’ 中文隶书 ‘FangSong’ 中文仿宋 ‘YouYuan’ 中文幼圆 ‘STSong’ 华文宋体 123456789101112import matplotlibmatplotlib.rcParams['font.family'] = 'STSong'matplotlib.rcParams['font.size'] = 20a = np.arange(0, 5, 0.01)plt.plot(a, np.sin(a*np.pi),'--')plt.xlabel(\"横轴（x）\")plt.ylabel(\"纵轴（y）\")#plt.savefig('test.png', dpi = 600)plt.show() fontproperties在有中文输出的地方，增加一个属性：fontproperties 1234567a = np.arange(0, 5, 0.05)plt.plot(a, np.sin(a*np.pi),'r+')plt.xlabel(\"横轴（x）\", fontproperties = 'SimHei', fontsize = 20)plt.ylabel(\"纵轴（y）\", fontproperties = 'SimHei', fontsize = 20)#plt.savefig('test.png', dpi = 600)plt.show() 文本显示包括横纵轴标签、标题、注解等。 函数 说明 plt.xlabel() 对X轴增加文本标签 plt.ylabel() 对Y轴增加文本标签 plt.title() 对图形整体增加文本标签 plt.text() 在任意位置增加文本 plt.annotate() 在图形中增加带箭头的注解 1234567891011121314import numpy as npa = np.arange(0, 5, 0.02)plt.plot(a, np.cos(a*np.pi),'r--')plt.xlabel('横轴：时间', fontproperties = 'SimHei', fontsize = 15, color = 'green')plt.ylabel('纵轴：振幅', fontproperties = 'SimHei', fontsize = 15)plt.title(r'正弦波实例$y = cos(2 \\pi x)$', fontsize = 25)plt.text(2, 1.2, r'$\\mu = 100$', fontsize = 15)plt.annotate(r'$\\pi$', xy = (3, -1),xytext = (5, -1.5), fontsize = 15, arrowprops = dict(facecolor = 'blue', shrink = 0, width = 5))plt.axis([-1, 6, -2, 2])plt.grid(True)plt.show() 子绘图区域plt.subplot2grid1plt.subplot2grid(GridSpec, CurSpec, colspan=1, rowspan=1) 思想：设定网格，选中网格，确定选中区域行列的数量。编号从0开始。 12345678ax1 = plt.subplot2grid((3, 3), (0, 0), colspan=3)ax1.plot([1, 2, 3])ax2 = plt.subplot2grid((3, 3), (1, 0), colspan=2)ax2.plot([3,2,5], 'r--')plt.subplot2grid((3, 3), (1, 2), rowspan=2)plt.subplot2grid((3, 3), (2, 0))plt.subplot2grid((3, 3), (2, 1))plt.show() GridSpec类1234567import matplotlib.gridspec as gridspecgs = gridspec.GridSpec(3, 3)ax1 = plt.subplot(gs[0, :])ax2 = plt.subplot(gs[1:3, 0:2])ax3 = plt.subplot(gs[1:3,2]) 基础图表 函数 说明 函数 说明 plt.plot(x,y,fmt,…) 绘制一个坐标图 plt.cohere(x,y,NFFT=256,Fs) 绘制X‐Y的相关性函数 plt.boxplot(data,notch,position) 绘制一个箱形图 plt.scatter(x,y) 绘制散点图，其中，x和y长度相同 plt.bar(left,height,width,bottom) 绘制一个条形图 plt.step(x,y,where) 绘制步阶图 plt.barh(width,bottom,left,height) 绘制一个横向条形图 plt.hist(x,bins,normed) 绘制直方图 plt.polar(theta, r) 绘制极坐标图 plt.contour(X,Y,Z,N) 绘制等值图 plt.pie(data, explode) 绘制饼图 plt.vlines() 绘制垂直图 plt.psd(x,NFFT=256,pad_to,Fs) 绘制功率谱密度图 plt.stem(x,y,linefmt,markerfmt) 绘制柴火图 plt.specgram(x,NFFT=256,pad_to,F) 绘制谱图 plt.plot_date() 绘制数据日期 散点图1234567import matplotlib.pyplot as pltimport numpy as npfig, ax = plt.subplots()ax.plot(10*np.random.rand(100), 10*np.random.rand(100), 'o')ax.set_title('Simple Scatter')plt.show() 饼图123456789import matplotlib.pyplot as pltlabels = 'Fogs', 'Hogs', 'Dogs', 'Logs'sizes = [15, 30, 45, 10]explode = (0, 0.1, 0, 0)plt.pie(sizes, explode = explode, labels = labels, autopct=\"%1.1f%%\", shadow = False, startangle = 90)plt.show() 12345678910import matplotlib.pyplot as pltlabels = 'Fogs', 'Hogs', 'Dogs', 'Logs'sizes = [15, 30, 45, 10]explode = (0, 0.1, 0, 0)plt.pie(sizes, explode = explode, labels = labels, autopct=\"%1.1f%%\", shadow = False, startangle = 90)plt.axis('equal')plt.show() 直方图1234567891011import numpy as npimport matplotlib.pyplot as pltnp.random.seed(0)mu, sigma = 100, 20a = np.random.normal(mu, sigma, size = 100)# 20为直方图的个数plt.hist(a, 20, normed=1, histtype='stepfilled', facecolor='blue', alpha=1)plt.title('Histgram')plt.show() 极坐标图12345678910111213141516import numpy as npimport matplotlib.pyplot as pltN = 20theta = np.linspace(0, 2*np.pi, N, endpoint=False)radii = 10*np.random.rand(N)width = np.pi/4*np.random.rand(N)print(width)ax = plt.subplot(111, projection = 'polar')bars = ax.bar(theta, radii, width = width, bottom = 0)for r, bar in zip(radii, bars): bar.set_facecolor(plt.cm.viridis(r/10)) bar.set_alpha(0.5) plt.show() [ 0.63318328 0.5528328 0.07871801 0.72215996 0.5609638 0.7844926 0.11737642 0.68182461 0.12762165 0.48345935 0.09724799 0.66602411 0.63406683 0.44697067 0.31980101 0.05432363 0.54775928 0.35621159 0.56710114 0.68045509] 12345678910111213141516171819import numpy as npimport matplotlib.pyplot as plt## 位置，单位为弧度theta = np.array([0, 45, 90, 135, 180, 270])*np.pi/180## 高度radii = [10, 2, 4, 6, 5, 5]## 宽度width = [0.8, 0.5, 0.2, 0.3, 0.2, 0.8]ax = plt.subplot(111, projection = 'polar')bars = ax.bar(theta, radii, width = width, bottom = 0)# 设置颜色和透明度for r, bar in zip(radii, bars): bar.set_facecolor(plt.cm.viridis(r/10)) bar.set_alpha(0.5) plt.show()","categories":[{"name":"Python模块","slug":"Python模块","permalink":"http://helloliangxw.com/categories/Python模块/"}],"tags":[{"name":"Matplotlib","slug":"Matplotlib","permalink":"http://helloliangxw.com/tags/Matplotlib/"}]},{"title":"Jupyter常用配置与使用方法","slug":"Jupyter常用配置与使用方法","date":"2017-04-22T01:19:00.000Z","updated":"2017-04-22T08:50:33.931Z","comments":true,"path":"2017/04/22/Jupyter常用配置与使用方法/","link":"","permalink":"http://helloliangxw.com/2017/04/22/Jupyter常用配置与使用方法/","excerpt":"","text":"配置文件路径Windows下配置文件的默认路径为C:\\Users\\USERNAME\\.jupyter\\jupyter_notebook_config.py 如何找到配置文件在cmd中输入jupyter notebook --generate-config如果配置文件已经存在，那么会出现如下信息： 从中可以看到配置文件存放的位置。注意，此时输入n，不要overwrite。 更改工作目录在配置文件中修改如下属性： 1c.NotebookApp.notebook_dir = r'E:\\MyDocuments\\Jupyter' Jupyter快捷键 快捷键 说明 Shift + Enter 执行当前cell，并自动跳到下一个cell Ctrl + Enter 执行当前cell，执行后不自动调转到下一个cell： Enter 进入当前cell的编辑模式 Esc 退出当前cell的编辑模式 双D 删除当前的cell L 为当前的cell加入line number F 查找 1 将当前的cell转化为具有一级标题的markdown 2 将当前的cell转化为具有二级标题的markdown 3 将当前的cell转化为具有三级标题的markdown Crtl + / 为一行或者多行添加/取消注释 z 撤销对某个cell的删除 Crtl Home 快速跳转到首个cell Crtl End 快速跳转到最后一个cell 作为command使用具体方法为：在command命令前加一个感叹号“!”： 1!dir 驱动器 E 中的卷是 documents 卷的序列号是 8A53-05D4 E:\\MyDocuments\\Jupyter\\Jupyter 的目录 2017/04/22 09:35 &lt;DIR&gt; . 2017/04/22 09:35 &lt;DIR&gt; .. 2017/04/22 09:13 &lt;DIR&gt; .ipynb_checkpoints 2017/04/22 09:23 &lt;DIR&gt; Jupyter常用配置_files 2017/04/22 09:35 3,591 Untitled.ipynb 2017/04/22 09:09 6,862 自定义Jupyter钩子函数，实现保存文件时自动生成md文件.ipynb 2 个文件 10,453 字节 4 个目录 275,366,404,096 可用字节 魔术命令Magic functions详见The cell magics in IPython。 常用命令 说明 %lsmagic 显示所有魔术命令 %run file.py 执行文件file.py %matplotlib inline 实现Matplotlib绘图 %pwd 当前工作目录 %load file.py 将当前路径下的file.py文件加载到当前cell %hist 历史输入命令 %pdb 异常发生后自动进入调试器 %reset 删除当前命名空间中的全部变量或名称 %who 显示当前命名空间中已经定义的变量 %time statement 给出代码的执行时间，statement表示一段代码 %timeit statement 多次执行代码，计算综合平均执行时间 1234import numpy as np a = np.random.randn(1000, 1000)%timeit np.dot(a, a) 10 loops, best of 3: 61.1 ms per loop 1%who a np 1%hist !dir %pwd %pwd import numpy as np a = np.random.randn(1000, 1000) %timeit np.dot(a, a) %who %who %hist 关于Matplotlib内嵌图表的输出格式缺省为PNG，可以通过%config命令修改这个配置。%config命令可以配置IPython中的各个可配置对象，其中InlineBackend对象为matplotlib输出内嵌图表时所使用的对象，我们配置它的figure_format=&quot;svg&quot;，这样将内嵌图表的输出格式修改为SVG。显示的图像也会更加清晰。 12%config InlineBackend.figure_format=\"svg\"%matplotlib inline 设置页面跳转 目标位置(the destination) 在目标位置添加下面语句: 1&lt;a id=&apos;the_destination&apos;&gt;&lt;/a&gt; id可以任意赋值。 本文在标题1（配置文件路径）处添加了该行代码。 跳转位置 在跳转文字后添加目标位置id： 点击跳转","categories":[{"name":"Jupyter配置","slug":"Jupyter配置","permalink":"http://helloliangxw.com/categories/Jupyter配置/"}],"tags":[]},{"title":"自定义Jupyter钩子函数，实现保存文件时自动生成md文件","slug":"自定义Jupyter钩子函数，实现保存文件时自动生成md文件","date":"2017-04-21T16:30:00.000Z","updated":"2017-04-22T04:29:09.412Z","comments":true,"path":"2017/04/22/自定义Jupyter钩子函数，实现保存文件时自动生成md文件/","link":"","permalink":"http://helloliangxw.com/2017/04/22/自定义Jupyter钩子函数，实现保存文件时自动生成md文件/","excerpt":"","text":"博主的博客平台是使用Hexo+GitHub搭建的，写文章主要使用Jupyter。Jupyter能够进行交互式的Python科学计算，支持MarkDown、Latex等多种格式，关键还是免费的！ Hexo要求文章的格式为md（MarkDown），并且所有的文章都是放置在BLOG_ROOT\\source\\_posts下（其中BLOG_ROOT为博客根目录）。 问题来了： Jupyter文件的默认格式为ipynb，每次都需要手动转换为md格式，然后再将md文件剪切到_posts目录下 Jupyter中用matplotlib绘制的图片，也需要手动移动到博客的相应目录下，才能在最终生成的博客中正常显示 两个字，麻烦！ 有没有什么方法能够在Ctrl+S保存文章时，自动生成md文件，并将相关的文件和文件夹移动到_post目录下？ 解决方法：在Jupyter配置文件（Windows下默认路径为C:\\Users\\USERNAME\\.jupyter\\jupyter_notebook_config.py）中有一个c.FileContentsManager.post_save_hook属性，通过该属性的名称post_save_hook就可以猜到，它定义了文件保存时的钩子函数。自定义钩子函数，就可以在保存文件时让Jupyter自动实现你所定义的操作。 开启Hexo资源文件管理功能根据Hexo的对资源文件夹的说明，在站点配置文件_config.yml中找到post_asset_folder，并设置为true： 12## _config.ymlpost_asset_folder: true 自定义钩子函数首先在配置文件中找到c.FileContentsManager.post_save_hook属性，打开其注释，并修改为： 1c.FileContentsManager.post_save_hook = output_post_save 其中output_post_save即自定义的钩子函数。函数定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import sysimport osimport shutilpjoin = os.path.join# 博客的md文章存放目录_DOCS_ROOT = r'E:\\MyDocuments\\GitHub\\myblog.github.io\\source\\_posts'## 钩子函数的函数名可以任意，函数参数及含义请参考Jupyter的配置文件def output_post_save(model, os_path, contents_manager): ## 获得当前文章的类型 ftype = model.get('type') ## 获得当前文章的名称，包括后缀名 fname = model.get('name') ## 仅处理IPython Notebook if ftype not in ['notebook']: return ## 未命名文件不处理 if 'Untitled' in fname: return # 添加jupyter路径，防止找不到nbconvert命令 sys.path.append(r\"D:\\Anaconda3\\Scripts\") # 调用nbconvert命令，将ipynb转换为md文件 os.system('jupyter nbconvert --to markdown &#123;&#125; '.format(os_path)) # 移动md文件到_post目录 md_path = os_path[:-5]+'md' os.system(r\"move &#123;&#125; &#123;&#125;\".format(md_path, _DOCS_ROOT)) # 移动图片文件夹 # 假设当前所写的文章为：first.ipynb，文章中由matplotlib生成了一幅图片my.png # Jupyter会在当前目录下建立一个图片文件夹，命名方式为：文章名称_files，如first_files # 然后将所有的图片都放置在first_files文件夹下 # 当文章转换为md时，my.png图片的引用方式为：![png](first_files/my.png) # jupyter_files_path即为Jupyter下图片文件夹绝对路径 jupyter_files_path = os_path[:-6]+'_files' # 判断图片文件夹是否存在： if os.path.exists(jupyter_files_path): # 根据Hexo对资源文件夹的管理方式： # 首先在博客的_posts文件夹下，新建与当前文章名称相同的文件夹，如_post\\first # hexo_sources_path即_posts下的资源文件夹的绝对路径 hexo_sources_path = pjoin(_DOCS_ROOT, fname[:-6]) if os.path.exists(hexo_sources_path): os.system(r\"rd /q/s &#123;&#125;\".format(hexo_sources_path)) os.system(r\"md &#123;&#125;\".format(hexo_sources_path)) # 最后将Jupyter中的图片文件夹移动到_posts下的资源文件夹中 hexo_sources_files_path = pjoin(hexo_sources_path, fname[:-6]+'_files') shutil.copytree(jupyter_files_path, hexo_sources_files_path) 主要实现功能在进行文章保存时，output_post_save函数主要实现了以下功能： 将ipynb文件转换为md文件 将md文件移动到_post目录下 判断Jupyter目录下是否存在图片文件夹 如果图片文件夹存在，就在_post下生成资源文件夹，并将图片文件夹移动到资源文件夹中","categories":[{"name":"Jupyter配置","slug":"Jupyter配置","permalink":"http://helloliangxw.com/categories/Jupyter配置/"}],"tags":[]},{"title":"机器学习-梯度下降","slug":"机器学习-梯度下降","date":"2017-04-21T02:05:00.000Z","updated":"2017-04-22T08:53:32.317Z","comments":true,"path":"2017/04/21/机器学习-梯度下降/","link":"","permalink":"http://helloliangxw.com/2017/04/21/机器学习-梯度下降/","excerpt":"","text":"数据展示读数据123456import pandas# Read data from csvpga = pandas.read_csv(\"pga.csv\")print(type(pga))print(pga.head()) &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; distance accuracy 0 290.3 59.5 1 302.1 54.7 2 287.1 62.4 3 282.7 65.4 4 299.1 52.8 数据归一化x' = \\frac{x-\\mu}{s}\\(\\mu\\)为平均值，\\(s\\)为标准差或极差。 1234# Normalize the datapga.distance = (pga.distance - pga.distance.mean()) / pga.distance.std()pga.accuracy = (pga.accuracy - pga.accuracy.mean()) / pga.accuracy.std()print(pga.head()) distance accuracy 0 0.314379 -0.707727 1 1.693777 -1.586669 2 -0.059695 -0.176699 3 -0.574047 0.372640 4 1.343083 -1.934584 展示12%matplotlib inline%config InlineBackend.figure_format=\"svg\" 123456import matplotlib.pyplot as pltplt.scatter(pga.distance, pga.accuracy)plt.xlabel('normalized distance')plt.ylabel('normalized accuracy')plt.show() 梯度下降代价函数cost(theta, X, y)用于计算代价函数\\(J(\\theta)\\) J(\\theta) = \\frac{1}{2m}\\sum_{i=1}^{m}(h_{\\theta}(x^{(i)})-y^{(i)})^2 \\(theta\\)\\(theta = [\\theta_0, \\theta_1, … ,\\theta_n]\\) \\(X\\)\\(X\\)为训练样本（为了与\\(theta\\)对应，\\(X\\)的第一列均为1） \\(y\\)\\(y\\)是与\\(X\\)对应的观测值 对于一份\\(n\\)个特征、\\(m\\)行观测样本的数据，\\(theta\\)的维数为\\(1\\times(n+1)\\)，\\(X\\)的维数为\\(m\\times(n+1)\\)，\\(y\\)的维数为\\(m\\times1\\)。 在计算代价函数时，推荐使用矩阵相乘的方式计算，不推荐使用循环。 12345def cost(theta, X, y): # 观测样本个数 m = len(X) # 计算代价函数 return np.sum( (np.sum(theta * X, 1).reshape(-1, 1) - y) ** 2 ) / (2 * m) 首先看一下当\\(theta0\\)为定值100时，代价函数随\\(theta1\\)的走势： 123456789101112131415161718import numpy as np# 构造X和ym = len(pga.accuracy)X = np.hstack(( np.ones((m,1)), pga.distance.values.reshape(m,1) ))y = pga.accuracy.values.reshape(m, 1)theta0 = 100theta1s = np.linspace(-3,2,100)COSTS = []for theta1 in theta1s: theta = np.array([theta0, theta1]).reshape(1, -1) J = cost(theta, X, y) COSTS.append(J)plt.plot(theta1s, COSTS)plt.xlabel('theta1')plt.ylabel('cost function')plt.show() 可以看出，\\(theta1\\)在[-1,0]的区间内，目标函数取得最小值。 下面看下，代价函数随\\(theta0、theta1\\)的变化： 123456789101112131415161718192021%matplotlib inlineimport matplotlib.pyplot as pltfrom mpl_toolkits.mplot3d import Axes3Dtheta0s = np.linspace(-3, 2, 100)theta1s = np.linspace(-3, 2, 100)COST = np.empty(shape=(100, 100))# Meshgrid for paramaters t0s, t1s = np.meshgrid(theta0s, theta1s)# for each parameter combination compute the costfor i in range(100): for j in range(100): theta = np.array([theta0s[i], theta1s[j]]).reshape(1, -1) COST[i, j] = cost(theta, X, y)# make 3d plotfig2 = plt.figure()ax = fig2.gca(projection='3d')ax.plot_surface(t0s, t1s, COST)plt.show() 一般情况下，用于线性回归的cost function都是凸函数，即只有全局最优解，没有局部最优解。 \\(\\theta\\)的更新批量梯度下降： \\theta_i := \\theta_i- \\frac{\\alpha}{m}\\sum_{j=1}^{m}(h_{\\theta}(x^{(j)})-y^{(j)}) x_i^{(j)}12345678910111213def gradientDescent(X, y, theta, alpha = 0.1, num_iters = 1000): m = len(y) n = X.shape[1] J = np.empty(num_iters) for i in range(num_iters): ## 更新theta theta -= alpha * np.sum( np.tile((np.sum(X * theta, 1).reshape(-1, 1) - y), (1, n)) * X, axis = 0)/m ## 计算更新后的目标函数 J[i] = cost(theta, X, y) return [J, theta] 123456[J, theta] = gradientDescent(X, y, np.zeros((1, 2)), alpha = 0.01, num_iters = 1000)print(theta)plt.scatter(range(1000), J, 5)plt.show() [[ 1.43777150e-14 -6.07571212e-01]] 正规方程正规方程： X^TX\\theta=X^Ty则: \\theta = (X^TX)^{-1}X^Ty使用正规方程时，无需进行特征缩放。 12theta = np.linalg.inv((X.T.dot(X))).dot(X.T).dot(y)print(theta) [[ 1.44016743e-14] [ -6.07598823e-01]] sklearn库123456789101112from sklearn.linear_model import LinearRegressionimport numpy as np# 通过np.newaxis为pga.distance增加一维print(\"Shape of the series:\", pga.distance.shape)print(\"Shape with newaxis:\", pga.distance[:, np.newaxis].shape)# lr.fit()中的X必须是个二维数据lr = LinearRegression()lr.fit(pga.distance[:, np.newaxis], pga.accuracy)print(lr.intercept_, lr.coef_[0]) Shape of the series: (197,) Shape with newaxis: (197, 1) 1.44099746415e-14 -0.607598822715 回归效果123456789101112%matplotlib inlineimport matplotlib.pyplot as pltplt.scatter(pga.distance, pga.accuracy)plt.xlabel('normalized distance')plt.ylabel('normalized accuracy')a = np.linspace(-3, 3, 100)b = lr.intercept_ + a * lr.coef_[0]plt.plot(a, b, 'r')plt.show()","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://helloliangxw.com/categories/机器学习/"}],"tags":[{"name":"梯度下降","slug":"梯度下降","permalink":"http://helloliangxw.com/tags/梯度下降/"}]},{"title":"Python-模块-math和random","slug":"Python-模块-math和random","date":"2017-04-20T01:26:00.000Z","updated":"2017-04-20T02:14:07.511Z","comments":true,"path":"2017/04/20/Python-模块-math和random/","link":"","permalink":"http://helloliangxw.com/2017/04/20/Python-模块-math和random/","excerpt":"","text":"math库 函数或属性名 说明 pi \\(\\pi\\)的近似值，15位小数 e 自然常数e的近似值，15位小数 ceil(x) 向上去整 floor(x) 向下去整 pow(x, y) \\(x^y\\) log(x) \\(ln(x)\\) log10(x) \\({log_{10}}^x\\) sqrt(x) \\(\\sqrt{x}\\) exp(x) \\(e^x\\) degrees(x) 弧度\\(\\rightarrow\\)角度 radians(x) 角度\\(\\rightarrow\\)弧度 sin(x) cos(x) tan(x) 三角函数 asin(x) acos(x) atan(x) 反三角函数 random库 函数名 说明 seed(x) 给随机数一个种子值，默认种子为系统时间戳 random() 生成一个[0, 1.0)的随机小数 uniform(a, b) 生成一个a到b的随机小数 randint(a, b) 生成一个a到b的随机整数 randrange(a,b,c) 生成一个区间为[a,b)、步长为c的列表，然后从列表中随机取一个数 choice(list) 从列表中随机取一个元素 shuffle(list) 将列表的元素随机打乱 sample(list, k) 从列表随机获取k个元素 随机种子的作用：设定相同的种子后，每次调用随即函数获得的随机数相同。因为计算机是一个确定设备，无法生成真正的随机数。所以，由计算机产生的随机数都是由一个种子开始的伪随机序列。相同的种子产生相同的伪随机序列，也有利于程序的验证执行。","categories":[{"name":"Python-模块","slug":"Python-模块","permalink":"http://helloliangxw.com/categories/Python-模块/"}],"tags":[]},{"title":"Python-模块-turtle","slug":"Python-模块-turtle","date":"2017-04-20T01:25:00.000Z","updated":"2017-04-20T01:25:33.540Z","comments":true,"path":"2017/04/20/Python-模块-turtle/","link":"","permalink":"http://helloliangxw.com/2017/04/20/Python-模块-turtle/","excerpt":"","text":"初识绘制蟒蛇1234567891011121314151617181920import turtle as tdef drawSnake(rad, angle, len, neckrad): for i in range(len): t.circle(rad, angle) t.circle(-rad, angle) t.circle(rad, angle/2) t.fd(rad) t.circle(neckrad+1, 180) t.fd(rad*2/3)t.setup(1000, 500, 0, 0)t.up()t.goto(-400, 0)t.down()t.pensize(30)t.pencolor('blue')t.seth(-40)drawSnake(40, 80, 5, 15) 函数解析 turtle.setup()turtle中的turtle.setup()函数用于启动一个图形窗口，它有四个参数turtle.setup(width, height, startx, starty)分别是：启动窗口的宽度，高度，以及窗口左上角在屏幕中的坐标位置。我们所使用的显示屏幕也是一个坐标系，该坐标系以左上角为原点，向右和向下分别是x轴和y轴： turtle.up()和turtle.down()turtle.up()为提起画笔turtle.down()为放下画笔 turtle.goto()初始时刻，小乌龟在启动窗口的正中央，坐标为(0, 0)（此为画图窗口的原点，而不是屏幕的原点），向右和向上为正方向。通过turtle.goto(x, y)可以将小乌龟移动到(x, y)坐标处。 turtle.pensize()turtle.pensize(size)函数表示小乌龟运动轨迹的宽度，单位为像素。 turtle.pencolor()turtle.pencolor(color)函数表示小乌龟运动轨迹的颜色。turtle采用RGB方式来定义颜色，如turtle.pencolor(“#3B9909”)。 turtle.seth()turtle.seth(angle)函数表示小乌龟初始时运动方向。输入参数是一个角度值，其中0表示向东，90度向北，180度向西，270度向南；负值表示的方向与正值表示的方向关于方向0对称： turtle.circle()turtle.circle(rad, angle)函数让小乌龟沿着一个圆形爬行。参数rad描述圆形轨迹圆心的位置，rad&gt;0时，圆心在当前速度方向的左侧；当rad0表示逆时针运动，angle&lt;0表示顺时针运动。 如下图所示，此时rad&gt;0，angle&lt;0 turtle.fd()turtle.fd(distance)或者turtle.forward()表示乌龟沿当前方向直线爬行，爬行距离为distance 彩色蟒蛇123456789101112131415161718192021222324import turtle as tdef drawSnake(rad, angle, len, neckrad): color = ['red', 'yellow', 'green', 'black', 'blue'] for i in range(len): # 更改画笔颜色 t.pencolor(color[i]) t.circle(rad, angle) t.circle(-rad, angle) t.pencolor('purple') t.circle(rad, angle/2) t.fd(rad) t.circle(neckrad+1, 180) t.fd(rad*2/3)t.setup(1000, 500, 0, 0)t.up()t.goto(-400, 0)t.down()t.pensize(30)t.seth(-40)drawSnake(40, 80, 5, 15) 常用函数控制画笔绘制状态的函数123pendown() | pd() | down() # 放下画笔penup() | pu() | up() # 提起画笔pensize(wid) | width(wid) # 画笔粗细 控制画笔颜色和字体函数1234567891011color() reset()begin_fill() # 填充图形前，调用该方法end_fill() # 填充图形结束filling() # 返回填充的状态，True为填充，False为未填充clear() # 清空当前窗口，但不改变当前画笔的位置screensize() # 设置画布的长和宽## 显示或隐藏小乌龟showturtle() | st() # 显示画笔的turtle形状hideturtle() | ht() # 隐藏画笔的turtle形状isvisible() # 如果turtle 可见，则返回Truewrite(str, move=False, align=\"left\", font =(\"Arial\",8,\"normal\") ) # 输出font字体的字符串 控制画笔运动的函数12345678910111213141516171819202122forward(distance) | fd(distance) # 前进backward(distance)| bk(distance) | back(distance) # 后退right(angle) | rt(angle) # 小乌龟向右侧转动一定的角度left(angle) | lt(angle) # 小乌龟向左侧转动一定的角度setheading(to_angle) # 设置当前朝向为angle角度position() | pos()goto(x,y)setposition(x,y) | setpos(x,y)circle(radius,extent ,steps)dot(r, *color) # 绘制一个半径 r颜色为color的圆点radians()stamp() clearstamp(stamp_id)clearstamps(n)speed(speed) # 设置画笔的绘制速度，参数在0-10之间heading()towards(x,y) distance(x,y )xcor() ycor()setx(x) sety(y)home() # 设置当前画笔位置为原点，朝向东undo() # 撤销画笔最后一步动作degrees(fullcircle = 360.0) TurtleScreen/Screen类的函数1234567891011121314151617181920bgcolor(*args)bgpic(picname)clearscreen()resetscreen()screensize(cwid ,canvh,bg )tracer(n ,delay )listen(xdummy ,ydummy )onkey((fun,key)onkeyrelease((fun,key)onkeypress(fun,key )onscreenclick(fun,btn=1,add)getcanvas()getshapes()turtles()window_height()window_width()bye()exitonclick()title(titlestring)setup(wid = _CFG[\"wid\"], h = _CFG[\"h\"], startx = _CFG[\"leftright\"], starty = _CFG[\"topbottom\"]) 应用举例绘制等边三角形123456789import turtle as tt.seth(60)t.fd(200)t.seth(-60)t.fd(200)t.seth(-180)t.fd(200)t.ht() 绘制红色五角星12345678910111213from turtle import *fillcolor(\"red\")pencolor(\"red\")begin_fill()while True: forward(200) right(144) # abs()是求当前位置离原点的距离 if abs(pos()) &lt; 1: breakend_fill()ht() 绘制太阳花123456789101112from turtle import *## 第一个为画笔颜色，第二个为填充颜色color('red', 'yellow')begin_fill()while True: forward(200) left(170) if abs(pos()) &lt; 1: breakend_fill()done() 绘制螺旋线123456789101112131415161718import turtleturtle.speed(\"fastest\")turtle.pensize(2)## 左侧turtle.up()turtle.goto(-100, 0)turtle.down()for x in range(100): turtle.forward(2 * x) turtle.left(90)## 右侧turtle.up()turtle.goto(100, 0)turtle.down() turtle.seth(90)for x in range(20): turtle.circle(5 * x, 180) 彩色螺旋线123456789101112import turtleimport timeturtle.pensize(2)turtle.bgcolor(\"black\")colors = [\"red\", \"yellow\", 'purple', 'blue']## 延迟更新图纸，可用于加速绘制复杂图形turtle.tracer(False)for x in range(400): turtle.forward(2*x) turtle.color(colors[x % 4]) turtle.left(91)turtle.tracer(True) 绘制一颗树123456789101112131415161718192021222324252627282930313233343536% matplotlib inlinefrom turtle import Turtle, mainloop def tree(plist, l, a, f): \"\"\" plist是画笔列表 l是枝干的长度 a是相邻两个枝干朝向之间的夹角 f是相邻两个枝干长度的比例 \"\"\" if l &gt; 5: # lst = [] for p in plist: p.forward(l) q = p.clone() # 对p进行克隆，克隆后的q与p具有相同的属性，包括位置，朝向等 p.left(a) q.right(a) lst.append(p) lst.append(q) tree(lst, l*f, a, f) def main(): p = Turtle() p.color(\"green\") p.pensize(5) p.hideturtle() p.speed(10) p.left(90) p.penup() p.goto(0,-200) p.pendown() t = tree([p], 200, 70, 0.63)main()","categories":[{"name":"Python-模块","slug":"Python-模块","permalink":"http://helloliangxw.com/categories/Python-模块/"}],"tags":[]},{"title":"Python-模块-time和datetime","slug":"Python-模块-time和datetime","date":"2017-04-20T01:24:00.000Z","updated":"2017-04-20T01:24:23.829Z","comments":true,"path":"2017/04/20/Python-模块-time和datetime/","link":"","permalink":"http://helloliangxw.com/2017/04/20/Python-模块-time和datetime/","excerpt":"","text":"time12345678import timeprint time.time()print time.localtime()for i in range(3): time.sleep(1) # 单位为s print \"tick!\" 1488184219.92 time.struct_time(tm_year=2017, tm_mon=2, tm_mday=27, tm_hour=16, tm_min=30, tm_sec=19, tm_wday=0, tm_yday=58, tm_isdst=0) tick! tick! tick! datetime12345import datetime as DTprint 'today is: ', DT.date.today()print 'local time now is: ', DT.datetime.now() # 当地时间print 'utc time now is: ', DT.datetime.utcnow() # utc时间 today is: 2017-02-27 time now is: 2017-02-27 16:42:10.219000 time now is: 2017-02-27 08:42:10.219000 将数字或字符串转化为相应的日期和时间（转换后的类型为日期类型）： 12345678910111213import datetime as DTpDate = DT.date(2017, 2, 27)pTime = DT.time(16,32)pDatetime = DT.datetime.strptime('20170227 16:34:11', '%Y%m%d %H:%M:%S')print pDateprint pTimeprint pDatetimeprint '--------------------------------'print type(pDate)print type(pTime)print type(pDatetime) 2017-02-27 16:32:00 2017-02-27 16:34:11 -------------------------------- &lt;type &#39;datetime.date&#39;&gt; &lt;type &#39;datetime.time&#39;&gt; &lt;type &#39;datetime.datetime&#39;&gt; 也可以进行日期之间的计算： 123456789101112131415import datetime as DTpDatetime = DT.datetime.strptime('20170227 16:37:11', '%Y%m%d %H:%M:%S')# 计算两个日期之间的天数days = ( DT.datetime.now()- pDatetime ).daysprint days# 计算儒略日DOY = ( pDatetime- DT.datetime(pDatetime.year, 1, 1) ).days + 1print DOY# 计算1h之后的日期aftTime = pDatetime + DT.timedelta(hours=1)print aftTime 0 58 2017-02-27 17:37:11","categories":[{"name":"Python-模块","slug":"Python-模块","permalink":"http://helloliangxw.com/categories/Python-模块/"}],"tags":[]},{"title":"Python-模块-正则表达式","slug":"Python-模块-正则表达式","date":"2017-04-20T01:21:00.000Z","updated":"2017-04-20T01:23:31.807Z","comments":true,"path":"2017/04/20/Python-模块-正则表达式/","link":"","permalink":"http://helloliangxw.com/2017/04/20/Python-模块-正则表达式/","excerpt":"","text":"常用字符和语法下图列出了Python支持的正则表达式元字符和语法： 分组123456import recontactInfo = 'Doe, John: 555-1212'm = re.search(r'(\\w+), (\\w+): (\\S+)', contactInfo)for i in range(4): print (m.group(i)) Doe, John: 555-1212 Doe John 555-1212","categories":[{"name":"Python-模块","slug":"Python-模块","permalink":"http://helloliangxw.com/categories/Python-模块/"}],"tags":[]},{"title":"Python面向对象基础","slug":"Python面向对象基础","date":"2017-04-20T01:19:00.000Z","updated":"2017-04-22T04:11:45.617Z","comments":true,"path":"2017/04/20/Python面向对象基础/","link":"","permalink":"http://helloliangxw.com/2017/04/20/Python面向对象基础/","excerpt":"","text":"类和对象按照Python通用规则： 类名用驼峰式表示，如HelloWorld 其他的属性、方法等，用_隔开，如this_is_object 类中方法的第一个参数必须是self 1234567891011121314#创建类class Person: # 类的公共属性 name = 'liangxw' # 类中的方法 def show(self, city): print ('my name is %s' %self.name) print (\"i live in &#123;0&#125;\".format(city))#根据Person创建对象,记得后面加个括号p = Person()p.show('china') my name is liangxw i live in china self相当于Java中的this关键字。self作为一个代词，并不一定要叫self。可以用其他单词来代替。但是必须得是这个类的所有方法的第一个参数。 12345678910111213#创建类class Person: name = 'liangxw' # 类中的方法 def show(this, city): # self改为this print ('my name is %s' %this.name) print (\"i live in &#123;0&#125;\".format(city))#根据Person创建对象,记得后面加个括号lxw = Person()lxw.show('china') my name is liangxw i live in china 构造函数构造函数，是一种特殊的方法。主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值。跟所有OOP语言一样，Python也有构造函数。 123456789101112131415# 创建类class Person: def __init__(self):#这就是构造函数，它的职责是在模型创建的初期，就完成一些动作 #简单的说就是，自定义的初始化步骤： #同样，它需要self来指代本身这个class self.eyeNumber = 2 def show(self): print (\"i have &#123;0&#125; eyes\".format(self.eyeNumber))#当你创建一个Foo类的时候，init会自动执行lxw = Person()lxw.show() i have 2 eyes 构造函数可以带更多的参数，用以初始化类本身。 1234567891011121314# 创建类class Person: def __init__(self, name, age): self.name = name self.age = age def show(self, city): print ('my name is %s' %self.name) print ('i am %s' %self.name) print (\"i live in &#123;0&#125;\".format(city)) lxw = Person('liangxw', 19)lxw.show('china') my name is liangxw i am liangxw i live in china 访问限制在Class内部，可以有属性和方法，而外部代码可以通过直接调用实例变量的方法来操作数据，这样，就隐藏了内部的复杂逻辑。在Python中，属性如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。 123456789101112131415class Student: def __init__(self, name, age): # 只有在类的内部可以访问 self.__name = name self.__age = age def show_details(self): print('name: %s' %self.__name) print('age: %s' %self.__age)LiLei = Student('LiLei', 12)# 修改年龄无效LiLei.__age = 20LiLei.show_details() name: LiLei age: 12 如此一来，年龄就不会被更改了。那么如何既保证安全，又能被外部修改呢？（总是有那么多变态的要求）Python使用OOP家族的传统思想：Getter+Setter 1234567891011121314151617181920212223242526272829class Student: def __init__(self, name, age): # 只有在类的内部可以访问 self.__name = name self.__age = age def show_details(self): print('name: %s' %self.__name) print('age: %s' %self.__age) def get_name(self): return self.__name def get_age(self): return self.__age def set_name(self, name): self.__name = name def set_age(self, age): self.__age = ageLiLei = Student('LiLei', 12)LiLei.show_details()print LiLei.get_age()print \"-------------------------------------\"LiLei.set_age(20)LiLei.show_details() name: LiLei age: 12 12 ------------------------------------- name: LiLei age: 20 Python中面向对象的三大特性面向对象的三大特性是指：封装、继承和多态。 封装 把内容封装在某处，即类中 从另一处调用被封装的内容 在类外使用对象进行调用 在类中使用self进行调用 继承继承，面向对象中的继承和现实生活中的继承相同，即：子可以继承父的内容（爸爸有的儿子都有）。例如，每个学生都有名字和年龄，木有问题。我们可以把Student作为父类。但是，每个学生自己，可能有自己不同的方法。比如，每个人有每个人不同的外号，不同的饮食习惯等等。 12345678910111213141516171819202122232425262728293031323334353637# 我们首先创建一个学生类，这个类是所有学生的父类class Student: def __init__(self, name, age): self.name = name self.age = age def show(self): print('name:%s' %self.name) print('age:%d' %self.age)# 然后，我们创建一个小学生类，小学生特点是，LOL sala无敌class PrimaryStudent(Student):# 因为是继承于学生类，所以我们写在括号内 # 这里我们可以不写构造函数，于是我们就是直接沿用Student类的构造函数 def show_motto(self): # 我们有一些新的独有的方法，会被叠加起来 print('my motto:不服？sala！') # 接下来，我们创建一个大学生类，大学生特点是，每个人都有个妹子。。class CollegeStudent(Student): def __init__(self, name, age, gf): #这里，我们改写一下构造函数 # 于是父类的__init__会被直接overwrite self.name = name self.age = age self.gf = gf def show_gf(self): print(\"my gf:%s\" %self.gf)# 来，创建一个小学生pStu = PrimaryStudent('小王', 7)pStu.show()#继承与爸爸的方法pStu.show_motto() # 独有的方法print \"-------------------------------------------\"cStu = CollegeStudent('王思聪', 29, '张雨馨')cStu.show()cStu.show_gf() name:小王 age:7 my motto:不服？sala！ ------------------------------------------- name:王思聪 age:29 my gf:张雨馨 所以，对于面向对象的继承来说，其实就是将多个类共有的方法提取到父类中，子类仅需继承父类而不必一一实现每个方法。这样可以极大的提高效率，减少代码的重复。 问题来了，如果想认多个干爹呢？Python和Java/C#的不同就是，Python可以多重继承，也就是，可以认很多干爹。但是干爹多了，就出了问题了。继承的时候，从谁先开始？有两种方式，分别是深度优先和广度优先。 经典类，按照深度优先的方式查找（即，找到一个爸爸，继续找这个爸爸的爸爸，再找爸爸的爸爸的爸爸，直到找到该方法为止。） 新式类，按照广度优先的方式查找（即，找到一个爸爸，然后在平辈之间查找另一个爸爸，找不到的话再找下一个爸爸。） 为什么有经典类和新类之分呢？这是个历史遗留问题，新类统一了类(class)和类型(type)，所以其实也是社区推荐的写法，只不过很多程序员都很懒。。在Python 2中，类和类型是不同的，如对象a是类A的一个实例，那么a.__class__返回__main__.A，type(a)返回总是&lt;type &#39;instance&#39;&gt;。而引入新类后，对象b是新类B的实例，b.__class__和type(b)都是返回__main__.B，这样就统一了。于是乎，在新版的Python中，这个经典类和新类的区别已经不存在，都统一使用广度优先。 123456789101112131415161718192021222324252627282930class D: def bar(self): print('D.bar')class C(D): def bar(self): print('C.bar')class B(D): passclass A(B, C): passa = A()a.bar()# python 2.x，深度优先# 执行bar方法时# 首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去D类中找，如果D类中么有，则继续去C类中找，如果还是未找到，则报错# 所以，查找顺序：A --&gt; B --&gt; D --&gt; C# 在上述查找bar方法的过程中，一旦找到，则寻找过程立即中断，便不会再继续找了# 输出为D.bar# python 3.x，广度优先# 执行bar方法时# 首先去A类中查找，如果A类中没有，则继续去B类中找，如果B类中么有，则继续去C类中找，如果C类中么有，则继续去D类中找，如果还是未找到，则报错# 所以，查找顺序：A --&gt; B --&gt; C --&gt; D# 在上述查找bar方法的过程中，一旦找到，则寻找过程立即中断，便不会再继续找了# 输出为C.bar 多态Python不支持多态并且也用不到多态，多态的概念是应用于Java和C#这一类强类型语言中，而Python崇尚“鸭子类型（Duck Typing）”。什么是鸭子类型？只要看起来像鸭子、走起来像鸭子、吃起来像鸭子，那么你就是鸭子（也可能是天鹅……）。其实翻译成中文最好是叫：好猫类型。也就是引用了小平同志的一句话，不管白猫黑猫，抓到老鼠就是好猫。 在Python中，只要是能“不报错运行”的类型，都可以塞进参数中去： 12345678910111213141516171819202122232425262728class F1: pass# 假设，S1是我们的正统类，它继承于根正苗红的F1，是我们的正统类class S1(F1): def show(self): print('S1.show')# S2是路人甲，是个歪瓜裂枣，但是他自己也有一个叫show的方法。class S2: def show(self): print('S2.show') # 在Java或C#中定义函数参数时，必须指定参数的类型，也即是说，我们如果用# Java写下面的Func，需要告知，obj是F1类还是其他什么东西。# 如果限定了F1，那么S2是不可以被采纳的。# 然而，在Python中，一切都是Obj，它不care你到底是什么类，直接塞进去就可以def Func(obj): \"\"\"Func函数需要接收一个F1类型或者F1子类的类型\"\"\" obj.show() s1_obj = S1()Func(s1_obj) # 在Func函数中传入S1类的对象 s1_obj，执行 S1 的show方法，结果：S1.shows2_obj = S2()Func(s2_obj) # 在Func函数中传入Ss类的对象 ss_obj，执行 Ss 的show方法，结果：S2.show S1.show S2.show 获取对象信息当我们拿到一个对象的引用时，如何知道这个对象是什么类型、有哪些方法呢？ type12345678910print type(123)print type('str')print type(None)print type(abs)class A: pass a = A()print type(A)print type(a) &lt;type &#39;int&#39;&gt; &lt;type &#39;str&#39;&gt; &lt;type &#39;NoneType&#39;&gt; &lt;type &#39;builtin_function_or_method&#39;&gt; &lt;type &#39;classobj&#39;&gt; &lt;type &#39;instance&#39;&gt; 12345print type(123)==type(456)print type('abc')==type('123')print type('abc')==type(123)print type('abc')==strprint type([])==list True True False True True isinstance()isinstance()可以告诉我们，一个对象是否是某种类型（包括继承关系）。 1print isinstance('a', str) # 等同于type True 12345678910111213class A: passclass B(A): passclass C(B): passa=A()b=B()c=C()print isinstance(c, C)print isinstance(c, B) True True dir()如果要获得一个对象的所有属性和方法，可以使用dir()函数，它返回一个包含字符串的列表， 12for i in dir('ABC'): print i __add__ __class__ __contains__ __delattr__ __doc__ __eq__ __format__ __ge__ __getattribute__ __getitem__ __getnewargs__ __getslice__ __gt__ __hash__ __init__ __le__ __len__ __lt__ __mod__ __mul__ __ne__ __new__ __reduce__ __reduce_ex__ __repr__ __rmod__ __rmul__ __setattr__ __sizeof__ __str__ __subclasshook__ _formatter_field_name_split _formatter_parser capitalize center count decode encode endswith expandtabs find format index isalnum isalpha isdigit islower isspace istitle isupper join ljust lower lstrip partition replace rfind rindex rjust rpartition rsplit rstrip split splitlines startswith strip swapcase title translate upper zfill 12345# 类似__xxx__的属性和方法在Python中都是有特殊用途的，比如__len__方法返回长度。# 当调用len()函数试图获取一个对象的长度，实际上，在len()函数内部，它自动去调用该对象的__len__()方法# 以下两种方法等效print 'ABC'.__len__()print len('ABC') 3 3 getattr()、setattr()以及hasattr()仅仅把属性和方法列出来是不够的，配合getattr()、setattr()以及hasattr()，我们可以直接操作一个对象的状态。 1234567class MyObject: def __init__(self): self.x = 9 def power(self): return self.x * self.xobj = MyObject() 1234# 紧接着，可以测试该对象的属性：print hasattr(obj, 'x') #有木有属性'x'print getattr(obj, 'x') # 获取属性'x'print hasattr(obj, 'y') # 有属性'y'吗？ True 9 True 1234setattr(obj, 'y', 19) # 设置一个属性'y'print hasattr(obj, 'y') # 有属性'y'吗？print getattr(obj, 'y') # 获取属性'y'print obj.y # 获取属性'y' True 19 19 12# 可以传入一个default参数，如果属性不存在，就返回默认值：print getattr(obj, 'z', 404) # 获取属性'z'，如果不存在，返回默认值404 404 1234567# 也可以获得对象的方法：print hasattr(obj, 'power') # 有属性'power'吗？print getattr(obj, 'power') # 获取属性'power'fn = getattr(obj, 'power') # 获取属性'power'并赋值到变量fnprint fn # fn指向obj.powerprint fn() # 调用fn()与调用obj.power()是一样的 实例属性和类属性Python是动态语言，根据类创建的实例可以任意绑定属性。给实例绑定属性的方法是通过实例变量，或者通过self变量 1234567class Student(object): # sex为类属性，规Student所有 name = 'Jim'stu = Student()# 给实例stu绑定一个score属性，归stu所有stu.score = 90 12345# 打印类的name属性print(Student.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性print stu.name Jim Jim 12stu.name = 'Michael' # 给实例绑定name属性print(stu.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性 Michael 123del stu.name # 如果删除实例的name属性print(stu.name) # 再次调用stu.name，由于实例的name属性没有找到，类的name属性就显示出来了 Jim 从上面的例子可以看出，在编写程序的时候，千万不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性。 模块和包Python的程序由包（package）、模块（module）和函数组成。包是由一系列模块组成的集合。模块是处理某一类问题的函数和类的集合。包就是一个完成特定任务的工具箱，Python提供了许多有用的工具包，如字符串处理、图形用户接口、Web应用、图形图像处理等。这些自带的工具包和模块安装在Python的安装目录下的Lib子目录中。 模块在Python中一个文件可以被看成一个独立模块，模块把Python代码分成一些有组织的代码段，通过导入的方式实现代码重用。导入模块时，是按照sys.path变量的值搜索模块，sys.path的值是包含每一个独立路径的列表，包含当前目录、python安装目录、PYTHONPATH环境变量，搜索顺序按照路径在列表中的顺序（一般当前目录优先级最高）。 查看自己的Python路径: 12import sysprint(sys.path) 如果发现你在某个地方写的文件（包）import错误，你就可以看看这个sys.path是否囊括了你那批文件的根目录。 导入模块使用import语句: 123import module1import module2import module3 或者： 1import module1,module2,module3 这两种方式的效果是一样的，但是第一种可读性比第二种好。 在导入时推荐按照下面的顺序导入模块，并且一般在文件首部导入所有的模块： python标准库 第三方模块 应用程序自定义模块 使用from-import语句导入模块的属性： 12345from module import name1,name2,name3# 导入全部属性（由于容易覆盖当前名称空间中现有的名字，所以一般不推荐使用，适合模块中变量名很长并且变量很多的情况）from module import *# 自定义导入模块名称，就是为了用的时候方便好记。import simplejson as json 包包将有联系的模块组织在一起，有效避免模块名称冲突问题，让应用组织结构更加清晰。 一个普通的Python应用程序目录结构： 注意：包必须至少含有一个__int__.py文件，该文件的内容可以为空。__int__.py用于标识当前文件夹是一个包。 12345678app/|---- __init__.py|---- A/ |---- __init__.py |---- a.py (a.py中有个名为testA的函数)|---- B/ |---- __init__.py |---- b.py (b.py中有个名为testB的函数) app是最顶层的包，a和b是它的子包，可以这样导入： 123456from app.A import afrom app.B.b import testB# 调用a.testA()testB() 每个目录下都有init.py文件，这个是初始化模块，from-import语句导入子包时需要它，可以在里面做一些初始化工作，也可以是空文件。 __init__.py定义的属性直接使用顶层包.子包的方式导入，如在目录a的__init__.py文件中定义init_db()方法，调用如下：12from app import AA.init_db() 12","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://helloliangxw.com/categories/Python基础/"}],"tags":[]},{"title":"Python面向对象进阶","slug":"Python面向对象进阶","date":"2017-04-20T01:19:00.000Z","updated":"2017-04-22T04:12:16.426Z","comments":true,"path":"2017/04/20/Python面向对象进阶/","link":"","permalink":"http://helloliangxw.com/2017/04/20/Python面向对象进阶/","excerpt":"","text":"__slot__Python是动态语言，可以对类的实例任意绑定属性。 通过__slot__就可以限定类的实例能够添加的属性。 12345678910import tracebackfrom types import MethodTypeclass MyClass(object): __slots__ = ['name', 'set_name']def set_name(self, name): self.name = namecls = MyClass() __slots__ = [&#39;name&#39;, &#39;set_name&#39;]表明，实例cls只能添加两种属性：name和set_name： 123456cls.name = 'Tom'cls.set_name = MethodType(set_name, cls)print(cls.name)cls.set_name('Jerry')print(cls.name) Tom Jerry 当视图绑定其他属性时，会报错： 1234try: cls.age = 30except AttributeError: traceback.print_exc() Traceback (most recent call last): File &quot;&lt;ipython-input-10-04e8bc9eda97&gt;&quot;, line 2, in &lt;module&gt; cls.age = 30 AttributeError: &#39;MyClass&#39; object has no attribute &#39;age&#39; 注意：__slots__仅对当前类的实例起作用，对继承的子类是不起作用的： 123456class ExtMyClass(MyClass): passext_cls = ExtMyClass()ext_cls.age = 30print(ext_cls.age) 30 @property@property可以将Python定义的函数“当做”属性访问，从而提供更加友好访问方式（相当于getter和setter） 只有@property表示只读。 同时有@property和@x.setter表示可读可写。 同时有@property和@x.setter和@x.deleter表示可读可写可删除。 12345678910111213141516171819202122232425262728293031323334import tracebackclass Student(object): def __init__(self, first_name, last_name): self._first_name = first_name self._last_name = last_name ## 读 @property def score(self): return self._score ## 写 @score.setter def score(self, value): # 对传入的值进行判断 # score只能是int，且在0-100之间 if not isinstance(value, int): raise ValueError('not int') elif (value &lt; 0) or (value &gt; 100): raise ValueError('not between 0 ~ 100') self._score = value @score.deleter #删除 def score(self): del self._score @property #读 def full_name(self): return '%s %s' % (self._first_name,self._last_name) 类Student对score属性设置了类型检查，只能设置为在0-100之间的整数，其他类型会报错： 12345678910111213stu = Student(\"pan\", \"jinlian\")stu.score = 75print(stu.score)try: stu.score = 'abc'except ValueError: traceback.print_exc()try: stu.score = 101except: traceback.print_exc() 75 Traceback (most recent call last): File &quot;&lt;ipython-input-47-0002bc38e8c2&gt;&quot;, line 6, in &lt;module&gt; stu.score = &#39;abc&#39; File &quot;&lt;ipython-input-41-9db1a0c27b9c&gt;&quot;, line 21, in score raise ValueError(&#39;not int&#39;) ValueError: not int Traceback (most recent call last): File &quot;&lt;ipython-input-47-0002bc38e8c2&gt;&quot;, line 11, in &lt;module&gt; stu.score = 101 File &quot;&lt;ipython-input-41-9db1a0c27b9c&gt;&quot;, line 23, in score raise ValueError(&#39;not between 0 ~ 100&#39;) ValueError: not between 0 ~ 100 删除掉score属性后，实例stu就不存在score属性了： 123print stu.scoredel stu.scoreprint stu.score 75 --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-48-e77428e32377&gt; in &lt;module&gt;() 1 print stu.score 2 del stu.score ----&gt; 3 print stu.score &lt;ipython-input-41-9db1a0c27b9c&gt; in score(self) 11 @property 12 def score(self): ---&gt; 13 return self._score 14 15 ## 写 AttributeError: &#39;Student&#39; object has no attribute &#39;_score&#39; 另外，由于full_name不存在full_name.setter，所以该属性为只读属性。尝试修改该属性会报错： 12print stu.full_namestu.full_name = \"Wu Song\" pan jinlian --------------------------------------------------------------------------- AttributeError Traceback (most recent call last) &lt;ipython-input-49-6424f5f489f7&gt; in &lt;module&gt;() 1 print stu.full_name ----&gt; 2 stu.full_name = &quot;Wu Song&quot; AttributeError: can&#39;t set attribute 类的定制（魔术方法）__str__当打印类的一个实例的时候，__str__函数被调用： 12345678910class MyClass: def __init__(self, name): self.name = name def __str__(self): print('print will call __str__ first.') return 'Hello ' + self.name + '!'cls = MyClass('Tom')print (cls) print will call __str__ first. Hello Tom! __iter__在Python中实现了__iter__方法的对象是可迭代的，实现了next()方法的对象是迭代器。即要想让一个迭代器工作，至少要实现__iter__和next()方法。很多时候使用迭代器完成的工作使用列表也可以完成，但是如果有很多值列表就会占用太多的内存，而且使用迭代器也让我们的程序更加通用、优雅、pythonic。 如果一个类想被用于for...in...循环，类似list或tuple那样，就必须实现一个__iter__()方法，该方法返回一个迭代对象，然后，Python的for循环就会不断调用该迭代对象的next()方法拿到循环的下一个值，直到遇到StopIteration错误时退出循环。 1234567891011121314151617181920class Fib(object): '''返回斐波那契数列的前十个''' def __init__(self): self._1, self._2 self._n = 0 def __iter__(self): return self def next(self): self._1, self._2 = self._2, self._1 + self._2 self._n = self._n + 1 if self._n &gt; 10: raise StopIteration() return self._1 for i in Fib(): print(i) 1 1 2 3 5 8 13 21 34 55 __getitem__如果一个类的实例能够像list[2]一样进行下标索引时，就需要实现__getitem__方法。 1234567891011class Fib: def __getitem__(self, n): a, b = 0, 1 for i in range(n): a, b = b, a + b return af = Fib()print(f[1])print(f[40]) 1 102334155 __call__在定义类的时候，实现__call__方法，这个类就成为可调用的。 换句话说，我们可以把这个类的对象当作函数来使用，相当于重载了括号运算符。 123456class MyClass: def __call__(self): print('You can call directly.')cls = MyClass()cls() You can call directly. 查看某个实例是否是可调用的： 1234print(callable(max))print(callable([1, 2, 3]))print(callable(None))print(callable('str')) True False False False 枚举类当我们需要定义常量时，一个办法是用大写变量通过整数来定义，例如月份： 123456JAN = 1FEB = 2MAR = 3...NOV = 11DEC = 12 好处是简单，缺点是：类型是int，并且仍然是变量。 更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了Enum类来实现这个功能： 12345678910from enum import EnumMonth = Enum('Month', ('Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',\\ 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'))for name, member in Month.__members__.items(): print(name, member, member.value)jan = Month.Janprint(jan) (&#39;Jan&#39;, &lt;Month.Jan: 1&gt;, 1) (&#39;Feb&#39;, &lt;Month.Feb: 2&gt;, 2) (&#39;Mar&#39;, &lt;Month.Mar: 3&gt;, 3) (&#39;Apr&#39;, &lt;Month.Apr: 4&gt;, 4) (&#39;May&#39;, &lt;Month.May: 5&gt;, 5) (&#39;Jun&#39;, &lt;Month.Jun: 6&gt;, 6) (&#39;Jul&#39;, &lt;Month.Jul: 7&gt;, 7) (&#39;Aug&#39;, &lt;Month.Aug: 8&gt;, 8) (&#39;Sep&#39;, &lt;Month.Sep: 9&gt;, 9) (&#39;Oct&#39;, &lt;Month.Oct: 10&gt;, 10) (&#39;Nov&#39;, &lt;Month.Nov: 11&gt;, 11) (&#39;Dec&#39;, &lt;Month.Dec: 12&gt;, 12) Month.Jan 如果需要更精确地控制枚举类型，可以从Enum派生出自定义类： 1234567891011121314151617from enum import Enum, unique# @unique装饰器可以帮助我们检查保证没有重复值。@uniqueclass Weekday(Enum): Sun = 0 # Sun的value被设定为0 Mon = 1 Tue = 2 Wed = 3 Thu = 4 Fri = 5 Sat = 6print (Weekday.Mon)print (Weekday.Mon.value)for name, member in Weekday.__members__.items(): print(name, member, member.value) Weekday.Mon 1 (&#39;Sun&#39;, &lt;Weekday.Sun: 0&gt;, 0) (&#39;Mon&#39;, &lt;Weekday.Mon: 1&gt;, 1) (&#39;Tue&#39;, &lt;Weekday.Tue: 2&gt;, 2) (&#39;Wed&#39;, &lt;Weekday.Wed: 3&gt;, 3) (&#39;Thu&#39;, &lt;Weekday.Thu: 4&gt;, 4) (&#39;Fri&#39;, &lt;Weekday.Fri: 5&gt;, 5) (&#39;Sat&#39;, &lt;Weekday.Sat: 6&gt;, 6)","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://helloliangxw.com/categories/Python基础/"}],"tags":[]},{"title":"Python代码碎片","slug":"Python代码碎片","date":"2017-04-20T01:19:00.000Z","updated":"2017-04-22T04:14:55.478Z","comments":true,"path":"2017/04/20/Python代码碎片/","link":"","permalink":"http://helloliangxw.com/2017/04/20/Python代码碎片/","excerpt":"","text":"字符串反转12345678910111213def reverse(lst, start, end): ''' 实现列表反转 ''' while start &lt; end: lst[start], lst[end] = lst[end], lst[start] start += 1 end -= 1sentence = ' hello! how are you! Fine. 'reverse(list(sentence), 0, len(strList)-1)print ''.join(strList) .eniF !uoy era woh !olleh 快速判断一个数是否为2的幂1234def is_pow2(n): return (n &amp; (n-1))==0print is_pow2(31) False 螺旋矩阵给定一个\\((m×n)\\)的矩阵，按照螺旋顺序，返回该矩阵的所有要素。 如：\\(\\textbf{A}=\\begin{bmatrix}1 &amp; 2 &amp; 3 \\\\4 &amp; 5 &amp; 6\\\\7 &amp; 8 &amp; 9\\end{bmatrix}\\)，返回：\\([1, 2, 3, 6, 9, 8, 7, 4, 5]\\)。 思路： 首先打印第一行，去掉第一行后剩余的矩阵记为temp 将temp逆时针翻转\\(90^o\\)，打印第一行 重复1-2步骤，直到矩阵temp的元素个数为0 1234567891011121314151617181920212223242526272829303132333435# 构造矩阵A，方便测试ROW, COL = 4, 3 # 行数，列数listA = [[ i for i in range(0 + j * COL, COL + j * COL)] for j in range(ROW)]# 打印Afor i in listA: print iprint \"----------------------------------------------\"listB=[]listTemp = listA while len(listTemp) &gt; 0: # 首先加入第一行 listB.extend(listA[0]) # 去掉第一行后，剩余矩阵的行数和列数 m = len(listA) - 1 n = len(listA[0]) listTemp = [[0] for i in range(n)] # 对剩余的矩阵进行逆时针旋转 for l in range(n - 1, -1, -1): t = [] for r in range(1, m + 1): t.append(listA[r][l]) listTemp[n-l-1]=t listA = listTemp print listB [0, 1, 2] [3, 4, 5] [6, 7, 8] [9, 10, 11] ---------------------------------------------- [0, 1, 2, 5, 8, 11, 10, 9, 6, 3, 4, 7] 矩阵转换给定矩阵\\(\\textbf{A}\\)，令矩阵\\(\\textbf{B}\\)（与\\(\\textbf{A}\\)同型）里每个元素\\(\\textbf{B}_{i,j}\\)的值等于\\(\\textbf{A}_{1,1}\\)到\\(\\textbf{A}_{i,j}\\)子矩阵元素的和。 思路： \\(\\textbf{B}_{1,1} = \\textbf{A}_{1,1}\\) 第一行：\\(\\textbf{B}_{1,j} = \\textbf{B}_{1,j-1} + \\textbf{A}_{1,j}\\) 第一列：\\(\\textbf{B}_{i,1} = \\textbf{B}_{i-1,1} + \\textbf{A}_{i,1}\\) 其他：\\(\\textbf{B}_{i,j} = \\textbf{B}_{i-1,j} + \\textbf{B}_{i,j-1} - \\textbf{B}_{i-1,j-1} + \\textbf{A}_{i,j}\\) 1234567891011121314151617181920212223242526272829# 构造矩阵A，方便测试ROW, COL = 8, 2 # 行数，列数listA = [[ i for i in range(0 + j * COL, COL + j * COL)] for j in range(ROW)]# 打印Afor i in listA: print iprint \"----------------------------------------------\"m, n = len(listA), len(listA[0])listB = listAfor i in range(m): for j in range(n): # 第0行 if (i == 0) &amp; (j &gt; 0): listB[0][j] = listB[0][j - 1] + listA[0][j] # 第0列 if (j == 0) &amp; (i &gt; 0): listB[i][0] = listB[i - 1][0] + listA[i][0] # 其他 if (i &gt; 0) &amp; (j &gt; 0): listB[i][j] = listB[i - 1][j] + listB[i][j - 1] - listB[i - 1][j - 1] + listA[i][j]for i in listB: print i [0, 1] [2, 3] [4, 5] [6, 7] [8, 9] [10, 11] [12, 13] [14, 15] ---------------------------------------------- [0, 1] [2, 6] [6, 15] [12, 28] [20, 45] [30, 66] [42, 91] [56, 120]","categories":[{"name":"Python代码","slug":"Python代码","permalink":"http://helloliangxw.com/categories/Python代码/"}],"tags":[]},{"title":"Python函数进阶","slug":"Python函数进阶","date":"2017-04-19T09:40:00.000Z","updated":"2017-04-22T04:07:30.044Z","comments":true,"path":"2017/04/19/Python函数进阶/","link":"","permalink":"http://helloliangxw.com/2017/04/19/Python函数进阶/","excerpt":"","text":"高阶函数将其他函数作为参数传入的函数叫高阶函数。 123456789# 如绝对值函数print abs(-10)# 在Python中一切都是对象print abs# 因此该函数也可以赋值给其他变量myAbs = absprint myAbs(-9) 10 &lt;built-in function abs&gt; 9 既然函数本身就可以作为一个变量，那函数也可以作为另一个函数的参数。 1234def MyAdd(x, y, op): return op(x) + op(y)print MyAdd(-10, 9, abs) 19 匿名函数Python使用lambda来创建匿名函数。 lambda只是一个表达式，函数体比def简单很多。 lambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。 lambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。 虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。 最重要的一点，lambda表达式可以体现你的逼格。 华尔街和伦敦银行高街最逼的一群人都是自诩用且只用函数式编程的。什么是函数式编程？就是类似于全篇程序都用Python中lambda这样的一行代码来解决问题。为什么他们逼？因为数学家们学编程的时候，脑子还在数学公式这条线上；他们不会写面对对象编程，只会死想出一条条公式来解决问题；其实这是智商堪忧的体现；但是因为投行基金们很倾向于聘用这群数学家转型的半吊子程序员；他们的使用习惯于是成了圈内高逼的体现；恩，葡萄就是这么酸。 语法1lambda [arg1 [,arg2,.....argn]]:expression 12mySum = lambda arg1, arg2: arg1 + arg2print (mySum(10, 20)) 30 123# 楼上这个，实际上等同于def mySum(arg1, arg2): return arg1 + arg2 reducePython中的reduce()内建函数是一个二元操作函数，他用来将一个数据集合(列表，元组等)中的所有数据进行如下操作：传给reduce()中的函数func() (必须是一个二元操作函数)，先对集合中的第1，2个数据进行操作，得到的结果再与第3个数据用func()函数运算，以此类推，最后得到一个结果。顾名思义，reduce()就是要把一个list给缩成一个值。所以你必须用二元操作函数。 123456789from functools import reducelst = [1,2,3,4,5]print(reduce(lambda x,y: x + y, lst))# 这里代表着，把list中的值，一个个放进lamda的x,y中# 如果你给出一个初始值，可以放在list后面print(reduce(lambda x,y: x + y, lst, 10))# 这样，x开始的时候被赋值为10，然后依次 15 25 mapmap()函数应用于每一个可迭代的项，返回的是一个结果list。如果有其他的可迭代参数传进来，map函数则会把每一个参数都以相应的处理函数进行迭代处理。map()可以使用任何的lambda函数操作，本质上是把原有的list根据lambda法则变成另外一个list 123456789101112# Py3里，外面需要套个list：# 这是为了让里面的值给显示出来，要不然你会得到这是个map函数# 而不是里面的值。# Py2不需要lst = [1, 2, 3]new_list = list(map(lambda i: i+1, lst))print(new_list)# 我们也可以把两个数组搞成一个单独的数组lst0 = [4,5,6]new_list = list(map(lambda x,y: x+y, lst, lst0))print(new_list) [2, 3, 4] [5, 7, 9] filterfilter()函数可以对序列做过滤处理，就是说可以使用一个自定的函数过滤一个序列。和map()类似，filter()也接收一个函数和一个序列。和map()不同的时，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 1234lst = [100, 20, 24, 50, 110]new_list = list(filter(lambda x: x &lt; 50, lst))# 同理，py3得套个list来转化成list函数，便于打印出来print(new_list) [20, 24] 装饰器装饰器就是函数的包装。直接上🌰。 函数装饰器博主有个小项目，项目中有个很简单很简单的函数： 1234def foo(): print 'call foo()'foo() call foo() 没错，就是这么简单！ 现在博主想看这个函数的运行时间： 12345678import timedef foo(): start = time.clock() print 'call foo()' end = time.clock() print 'time used:', end - startfoo() call foo() time used: 0.000371863878172 很好，功能看起来无懈可击。 可是DT的博主第二天对foo()不感兴趣了，想看另外一个函数foo2()的运行时间。第三天想看foo3()函数的运行时间。。。 怎么办呢？如果把foo()的函数体（第6行）换成foo2()或者foo3()的函数体，就犯了大忌了。修改、复制什么的难道不是最讨厌了么！而且，如果博主某天脑抽想看其他100个函数的运行时间呢？要修改复制100次吗？ 以不变应万变！ 12345678910111213141516import time def foo(): print 'call foo()' def foo2(): print 'call foo2()' def timeit(func): start = time.clock() func() end =time.clock() print 'time used:', end - start timeit(foo) timeit(foo2) call foo() time used: 0.000322124124068 call foo2() time used: 1.81589575732e-05 看起来逻辑上并没有问题，一切都很美好并且运作正常！ 但是，我们似乎修改了调用部分的代码。原本我们是这样调用的：foo()，修改以后变成了：timeit(foo)。这样的话，会出现以下的问题：如果项目中foo()在N处都被调用了，就不得不去修改这N处的代码（更极端的，其中某处调用的代码是交给别人写的，无法修改）。 最大限度的少改动！ 1234567891011121314151617181920import time def foo(): print 'call foo()'# 定义一个计时器，传入一个，并返回另一个附加了计时功能的方法def timeit(func): # 定义一个内嵌的包装函数，给传入的函数加上计时功能的包装 def wrapper(): start = time.clock() func() end =time.clock() print 'time used:', end - start # 将包装后的函数返回 return wrapper foo = timeit(foo)foo() call foo() time used: 0.000342651641404 这样，一个简易的计时器就做好了！我们只需要在调用foo()之前，加上foo = timeit(foo)，就可以达到计时的目的，这也就是装饰器的概念，看起来像是foo()被timeit()装饰了。 上面这段代码看起来似乎已经不能再精简了，Python提供了一个语法糖来降低字符输入量。 123456789101112131415import time def timeit(func): def wrapper(): start = time.clock() func() end =time.clock() print 'used:', end - start return wrapper @timeitdef foo(): print 'call foo()'foo() call foo() used: 0.000329624563165 重点关注第11行的@timeit，在定义上加上这一行与另外写foo = timeit(foo)完全等价，千万不要以为@有另外的魔力。 这样除了字符输入少了一些，还有一个额外的好处：看上去更有装饰器的感觉。 所以，本质上来讲，用装饰器@decorator来装饰某个函数时，其实是做了下面这件事儿： 123@decoratordef func(): pass 变成了： 1func = decorator(func) 再简单点说，就是把一个函数传到另外一个函数中，再返回给自己。 可以给装饰器带参数：123@decorator(arg1, arg2)def func(): pass 相当于： 1func = decorator(arg1,arg2)(func) 123456789101112131415161718def addWords(**kwds): # 对参数进行解析 pre = \"&#123;0&#125;\".format(kwds[\"prefix\"]) if \"prefix\" in kwds else \"\" suf = \"&#123;0&#125;\".format(kwds[\"suffix\"]) if \"suffix\" in kwds else \"\" # 真实的装饰器 def real_decorator(func): def wrapper(): return pre + \" + \" + func() + \" + \" + suf return wrapper return real_decorator@addWords(prefix = 'Good', suffix = \"Nice\")def foo(): return \"hello world\"print foo() Good + hello world + Nice foo()就是一个简单的打印”hello world”的函数。装饰器的功能是在”hello world”的前后各加一个单词，而加什么单词由装饰起的参数而定。 12345@addWords(prefix = 'LOL', suffix = \"SALA\")def foo(): return \"hello world\"print foo() LOL + hello world + SALA 我们也可以搞多个装饰： 1234@decorator_one@decorator_twodef func(): pass 相当于： 1func = decorator_one(decorator_two(func)) 123456@addWords(prefix = 'LOL', suffix = \"SALA\")@addWords(prefix = 'DOTA', suffix = \"SOLO\")def foo(): return \"hello world\"print foo() LOL + DOTA + hello world + SOLO + SALA 我们来看个实用的网页编程的case: 12345678910111213141516def makeHtmlTag(tag, **kwds): css_class = \" class='&#123;0&#125;'\".format(kwds[\"css_class\"]) if \"css_class\" in kwds else \"\" def real_decorator(fn): def wrapped(): return \"&lt;\" + tag + css_class + \"&gt;\" + fn() + \"&lt;/\" + tag + \"&gt;\" return wrapped return real_decorator @makeHtmlTag(tag=\"b\", css_class=\"bold_css\")@makeHtmlTag(tag=\"i\", css_class=\"italic_css\")def hello(): return \"hello world\" print(hello()) &lt;b class=&#39;bold_css&#39;&gt;&lt;i class=&#39;italic_css&#39;&gt;hello world&lt;/i&gt;&lt;/b&gt; 类装饰器类装饰器相比函数装饰器，具有灵活度大，高内聚、封装性等优点。其实现起来主要是靠类内部的__call__方法，当使用@形式将装饰器附加到函数上时，就会调用此方法，下面时一个实例: 1234567891011121314151617class decorator(object): def __init__(self, fn): print(\"1. inside decorator.__init__()\") self.fn = fn def __call__(self): print(\"3. inside decorator.__call__()\") self.fn()@decoratordef foo(): print(\"4. inside foo()\")print(\"2. Finished decorating foo()\") foo() 1. inside decorator.__init__() 2. Finished decorating foo() 3. inside decorator.__call__() 4. inside foo() 上面的例子也展示了程序运行的流程。 类装饰器比函数装饰器看着清楚点儿，这样我们再把刚刚的网页编程那段改一下，就得到： 1234567891011121314151617class makeHtmlTagClass(object): def __init__(self, tag, css_class=\"\"): self._tag = tag self._css_class = \" class='&#123;0&#125;'\".format(css_class) if css_class !=\"\" else \"\" def __call__(self, fn): def wrapped(*args): return \"&lt;\" + self._tag + self._css_class + \"&gt;\" + fn(*args) + \"&lt;/\" + self._tag + \"&gt;\" return wrapped@makeHtmlTagClass(tag=\"b\", css_class=\"bold_css\")@makeHtmlTagClass(tag=\"i\", css_class=\"italic_css\")def hello(name): return \"Hello, &#123;&#125;\".format(name) print(hello(\"Baby\")) &lt;b class=&#39;bold_css&#39;&gt;&lt;i class=&#39;italic_css&#39;&gt;Hello, Baby&lt;/i&gt;&lt;/b&gt; 装饰器的副作用： 因为装饰起的因素，我们原本的hello()函数其实已经变成了一个叫wrapper()函数。 比如，你再调用__name__的时候，他会告诉你，这是wrapper, 而不是hello: 1print hello.__name__ wrapped 当然，虽然功能效果不变，但是有些处女座的童鞋会觉得很不爽。所以，Python的functool包中提供了一个叫wrap的装饰起来消除这样的副作用： 12345678910111213141516171819202122from functools import wrapsdef hello(fn): @wraps(fn) def wrapper(): print(\"hello, %s\" % fn.__name__) fn() print(\"goodby, %s\" % fn.__name__) return wrapper @hellodef foo(): '''foo help doc''' print(\"i am foo\") pass foo()print '----------------------'print(foo.__name__)print(foo.__doc__) hello, foo i am foo goodby, foo ---------------------- foo foo help doc 经典案例最后，看一个经典的例子，斐波那契数列： 123456789101112131415161718192021222324from functools import wrapscache = &#123;&#125;miss = object()def memory(fn): @wraps(fn) def wrapper(*args): result = cache.get(args, miss) if result is miss: result = fn(*args) cache[args] = result return result return wrapper @memorydef fib(n): if n &lt; 2: return n return fib(n - 1) + fib(n - 2)print fib(10) 55 我们知道，这个递归是相当没有效率的，因为会重复调用。比如：我们要计算fib(5)，于是其分解成fib(4) + fib(3)，而fib(4)分解成fib(3)+fib(2)，fib(3)又分解成fib(2)+fib(1)…… 你可看到，基本上来说，fib(3), fib(2), fib(1)在整个递归过程中被调用了两次。而我们用装饰器，在调用函数前查询一下缓存，如果没有再调用，如果有就从缓存中返回值。这样，这个递归从二叉树式的递归成了线性的递归。 偏函数Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。 在介绍函数参数的时候，我们讲到，通过设定参数的默认值，可以降低函数调用的难度。而偏函数也可以做到这一点。举例如下： int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换： 1print int('110') 110 但int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换： 1print int('110', base = 2) 6 假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去： 12345def int2(x, base=2): return int(x, base)print int2('1000')print int2('1111') 8 15 functools.partial就是帮助我们创建一个偏函数的，不需要我们自己定义int2()，可以直接使用下面的代码创建一个新的函数int2： 1234import functoolsint2 = functools.partial(int, base=2)print int2('1000000')print int2('1010101') 64 85 所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。 注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值： 1print int2('1000000', base=10) 1000000 最后，创建偏函数时，实际上可以接收3个参数： 函数对象 *args **kwds 1234int2 = functools.partial(int, base=2) # 接收的是**kwdsmax10 = functools.partial(max, 10) # 接收的是*argsprint max10(5, 7, 6) 10","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://helloliangxw.com/categories/Python基础/"}],"tags":[]},{"title":"Python函数与递归","slug":"Python函数与递归","date":"2017-04-19T09:33:00.000Z","updated":"2017-04-22T04:06:18.563Z","comments":true,"path":"2017/04/19/Python函数与递归/","link":"","permalink":"http://helloliangxw.com/2017/04/19/Python函数与递归/","excerpt":"","text":"函数函数定义1234567def func(arg1, arg2): # 返回元组 return arg1, arg2t = func(1, 2)print(t)print(type(t)) (1, 2) &lt;class &#39;tuple&#39;&gt; 默认参数123456789101112def func(arg1, arg2 = 200): return arg1, arg2print(func(1))print(func(1, 2))# 调用时可以改变参数顺序print(func(10, arg2 = 2))print(func(arg2 = 2, arg1 = 1))# 下面这种调用方式会出错# func(arg2 = 2, 10) (1, 200) (1, 2) (10, 2) (1, 2) 变长参数变长参数必须放在参数列表的最后。一共有两种形式。第一种将变长参数包装成tuple： 12345678def func(name, *args): # 变长参数自动包装成tuple print(type(args)) print(args) print(args[0])func('Tom', 1, 2 ,'abc') &lt;class &#39;tuple&#39;&gt; (1, 2, &#39;abc&#39;) 1 第二种将变长参数包装成dict： 1234567def func(name, **args): # 变长参数自动包装成dict print(type(args)) print(args) print(args['China']) func('Tom', China='Beijing', UK='London') &lt;class &#39;dict&#39;&gt; {&#39;China&#39;: &#39;Beijing&#39;, &#39;UK&#39;: &#39;London&#39;} Beijing 1234567891011121314def func(a, b, c = 0, *args0, **args1): print(a, b, c) print(args0) print(args1)func(1, 2)print(\"--------------------------------------\")func(1, 2, 3)print(\"--------------------------------------\")func(1, 2, 3, 'a', 'b', 'c')print(\"--------------------------------------\")func(1, 2, 3, 'a', 'b', China='Beijing', UK='London')print(\"--------------------------------------\")func(1, 2, 3, *('a', 'b'), **&#123;'China':'Beijing', 'UK':'London'&#125;) 1 2 0 () {} -------------------------------------- 1 2 3 () {} -------------------------------------- 1 2 3 (&#39;a&#39;, &#39;b&#39;, &#39;c&#39;) {} -------------------------------------- 1 2 3 (&#39;a&#39;, &#39;b&#39;) {&#39;China&#39;: &#39;Beijing&#39;, &#39;UK&#39;: &#39;London&#39;} -------------------------------------- 1 2 3 (&#39;a&#39;, &#39;b&#39;) {&#39;China&#39;: &#39;Beijing&#39;, &#39;UK&#39;: &#39;London&#39;} 函数作为变量Python中一切皆对象，因此函数也可以最为变量： 12345def func(args): print(args*2)f = funcf('a') aa 123456789101112131415161718192021222324252627282930313233# 根据比较方法参数cmpMethod，对列表进行排序def theSort(dataList, cmpMethod = None): if not cmpMethod: return dataList else: return cmpMethod(dataList) # 从小到大排序（冒泡排序）def bubbleSortAscent(dataList): length = len(dataList) for i in range(0, length): for j in range(i + 1, length): if dataList[j] &lt; dataList[i]: temp = dataList[i] dataList[i] = dataList[j] dataList[j] = temp return dataList# 从大到小排序（冒泡排序）def bubbleSortDescent(dataList): length = len(dataList) for i in range(0, length): for j in range(i + 1, length): if dataList[j] &gt; dataList[i]: temp = dataList[i] dataList[i] = dataList[j] dataList[j] = temp return dataListprint(theSort([1, 3, 2, 5, 0]))print(theSort([1, 3, 2, 5, 0], bubbleSortAscent))print(theSort([1, 3, 2, 5, 0], bubbleSortDescent)) [1, 3, 2, 5, 0] [0, 1, 2, 3, 5] [5, 3, 2, 1, 0] 12345def Do(datas, method): return method(datas)print(Do([1, 2, 3], sum))print(Do([1, '2', 3], set)) 6 {1, 3, &#39;2&#39;} 命名关键字参数1234def func(a, b, c, *, China, UK): print(China, UK)func(1, 2, 3, China = 'Beijing', UK = 'London') Beijing London 递归函数定义中使用函数自身的方法。经典例子：阶乘。 n!=n(n-1)(n-2)...1=\\left\\{\\begin{matrix} 1 && n=0 \\\\\\\\ n(n-1)! && otherwrise \\end{matrix}\\right.其中\\(n=0\\)称为该递归的基例。 递归特征： 递归不是循环 （一个或多个）基例不需要递归，否则递归就会无限循环 所有的递归链都要以一个基例结尾 PS：Python默认“递归深度的最大值”为900，达到900次调用时，程序就会终止。 阶乘1234567def fact(n): if n==0: return 1 else: return fact(n-1) * nfact(3) 6 求和123456789def MySum(i): if i &lt; 0: raise ValueError elif i &lt;= 1: return i else: return i + MySum(i-1)print(MySum(3)) 6 字符串反转123456def strReverse(string): if string == \"\": return string else: return strReverse(string[1:])+string[0]strReverse(\"123456789\") &#39;987654321&#39; 斐波那契数列12345678910def fib(n): if n &lt; 1: raise ValueError elif n &lt;= 2: return 1 else: return fib(n-1) + fib(n-2)print fib(1), fib(2), fib(3), fib(4), fib(5), fib(6), fib(7) 汉诺塔问题12345678910def hnt(n, source, target, helper): if n == 1: print source + '=&gt;' + target else: hnt(n-1, source, helper, target) print source + '=&gt;' + target hnt(n-1, helper, target, source)hnt(3, 'A', 'B', 'C')","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://helloliangxw.com/categories/Python基础/"}],"tags":[]},{"title":"Python判断、循环和异常处理","slug":"Python判断、循环和异常处理","date":"2017-04-19T09:31:30.000Z","updated":"2017-04-22T04:05:25.600Z","comments":true,"path":"2017/04/19/Python判断、循环和异常处理/","link":"","permalink":"http://helloliangxw.com/2017/04/19/Python判断、循环和异常处理/","excerpt":"","text":"条件判断注意判断条件后的冒号 12345678910# 条件判断a = 100b = 200c = 300if a == 100: print(a)elif b == 200: print(b)else: print(c) 100 123456# None的判断x = Noneif x is None: #使用 x == None判断也行，但不推荐 print('x is None')elif not x: # 或者x is not None print('x is not None') x is None 循环12for i in range(1,5,2): print(i) 1 3 异常处理12345678910try: inNum = 20/int(input(\"请输入一个整数：\"))except ValueError as obj: print(obj)except ZeroDivisionError: print(\"0不能作除数\")else: print(\"No Exceptions\")finally: print(\"END\") 请输入一个整数：25 No Exceptions END","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://helloliangxw.com/categories/Python基础/"}],"tags":[]},{"title":"Python容器","slug":"Python容器","date":"2017-04-19T09:31:00.000Z","updated":"2017-04-22T04:07:59.366Z","comments":true,"path":"2017/04/19/Python容器/","link":"","permalink":"http://helloliangxw.com/2017/04/19/Python容器/","excerpt":"","text":"容器类型 - list tuple dict set 元素类型 任意 任意 任意 任意 能否改变 可以 不可以 可以 可以 是否有序 有序 有序 无序 无序 list列表特点： 元素类型任意 支持索引访问 元素可以修改 常用方法： 方法 说明 append(x) 列表末尾增加元素x insert(i, x) 在位置i前添加元素x sort() 排序 count(x) 列表中x的个数 reverse() 列表反转 remove(x) 删除列表中第一次出现的元素x index(x) 列表中第一次出现x的位置 pop(i) 取出位置i的元素，并删除这个元素 123456# 可以是任意类型theList = [1, 2, 'a', (1, 2), &#123;1:\"one\", 2:\"two\"&#125;]print type(list)print type(theList)theList[0]=2print theList &lt;type &#39;type&#39;&gt; &lt;type &#39;list&#39;&gt; [2, 2, &#39;a&#39;, (1, 2), {1: &#39;one&#39;, 2: &#39;two&#39;}] 123456# 列表引用theList = [1, 2, 'a', (1, 2), &#123;1:\"one\", 2:\"two\"&#125;]print theList[0]print theList[-1]print theList[-2]print theList[::-1] # 列表反转 1 {1: &#39;one&#39;, 2: &#39;two&#39;} (1, 2) [{1: &#39;one&#39;, 2: &#39;two&#39;}, (1, 2), &#39;a&#39;, 2, 1] 1234567891011# 添加元素theList = [1, 2, 'a', (1, 2), &#123;1:\"one\", 2:\"two\"&#125;]theList.append('china') # 添加单个元素print theListtheList.extend([10, 20]) # 添加数组print theListtheList.append([30, 40]) # 使用append添加数组时，仍然是添加单个元素print theList [1, 2, &#39;a&#39;, (1, 2), {1: &#39;one&#39;, 2: &#39;two&#39;}, &#39;china&#39;] [1, 2, &#39;a&#39;, (1, 2), {1: &#39;one&#39;, 2: &#39;two&#39;}, &#39;china&#39;, 10, 20] [1, 2, &#39;a&#39;, (1, 2), {1: &#39;one&#39;, 2: &#39;two&#39;}, &#39;china&#39;, 10, 20, [30, 40]] 12345678# 删除元素theList = [1, 2, 'a', (1, 2), &#123;1:\"one\", 2:\"two\"&#125;]theList.remove(1)print theListtheList.remove('a')print theListdel(theList[-1])print theList [2, &#39;a&#39;, (1, 2), {1: &#39;one&#39;, 2: &#39;two&#39;}] [2, (1, 2), {1: &#39;one&#39;, 2: &#39;two&#39;}] [2, (1, 2)] 1234# 修改元素theList = [1, 2, 'a', (1, 2), &#123;1:\"one\", 2:\"two\"&#125;]theList[0] = 100print theList [100, 2, &#39;a&#39;, (1, 2), {1: &#39;one&#39;, 2: &#39;two&#39;}] 123# 查找元素位置print theList.index('a')print theList.index((1, 2)) 2 3 123456789# 遍历theList = [1, 2, 'a', (1, 2), &#123;1:\"one\", 2:\"two\"&#125;]for i in theList: print iprint \"--------------------------------------\"for i in range(0, len(theList)): print theList[i] 1 2 a (1, 2) {1: &#39;one&#39;, 2: &#39;two&#39;} -------------------------------------- 1 2 a (1, 2) {1: &#39;one&#39;, 2: &#39;two&#39;} 123456789101112# 判断空列表lst = []if not lst: print \"empty\" if len(lst) == 0: print \"empty\" if lst is None: # 不能这么写，None什么都不是，[]在内存中也是分配空间了 print \"empty\"else: print \"not empty\" empty empty not empty 123456789# 在一个列表中找到两个数，这两个数的和为目标数def TwoSum(number_list, target): for i in range(len(number_list)-1): for j in range(len(number_list)-1): if number_list[i] + number_list[j] == target: return &#123;str(i) : number_list[i], str(j) : number_list[j]&#125; return &#123;'-1':-1, '-1':-1&#125;print TwoSum([1, 2, 4, 5, 3, 6], 9) {&#39;3&#39;: 5, &#39;2&#39;: 4} tuple元组即不可变数组，除了不可变之外，其他特性与list相同（任意类型，有序） 特点： 元素类型任意 支持索引访问 元素不可修改 元组不可变的意义?代码更加安全！ 12345t = (1, 2, 'a')print type(t)print tprint len(t)print t.index(1) &lt;type &#39;tuple&#39;&gt; (1, 2, &#39;a&#39;) 3 0 dict字典无序的键值对 注意：列表不能作为字典的键！ 常用字典方法： 方法名 说明 .keys() 返回一个包含字典所有Key的列表 .values() 返回一个包含字典所有value的列表 .Items() 返回一一个包含所有键值的列表 .clear() 删除字典中的所有项目 .get(key) 返回字典中key对应的值 .pop(key) 删除并返回字典中key对应的值 .update(dict) 将字典中的键值添加到字典中 12345d = &#123;1 : 'one', 2 : 'two', 'three' : 3&#125;print(type(d))print(d)print(len(d))print(d[1]) &lt;class &#39;dict&#39;&gt; {1: &#39;one&#39;, 2: &#39;two&#39;, &#39;three&#39;: 3} 3 one 123# 添加keyd['China']='Beijing'print(d) {1: &#39;one&#39;, 2: &#39;two&#39;, &#39;three&#39;: 3, &#39;China&#39;: &#39;Beijing&#39;} 1234# 删除keyd = &#123;1 : 'one', 2 : 'two', 'three' : 3&#125;del(d['three'])print(d) {1: &#39;one&#39;, 2: &#39;two&#39;} 123456# 修改valued = &#123;1 : 'one', 2 : 'two', 'three' : 3&#125;d['3'] = 3print (d)d['three'] = 333print (d) {1: &#39;one&#39;, 2: &#39;two&#39;, &#39;three&#39;: 3, &#39;3&#39;: 3} {1: &#39;one&#39;, 2: &#39;two&#39;, &#39;three&#39;: 333, &#39;3&#39;: 3} 123# 判断key是否存在print(1 in d)print('three' in d) True True 字典的遍历 遍历字典的键keyfor key in dictionaryName.keys(): print.(key) 遍历字典的值valuefor value in dictionaryName.values(): print.(value) 遍历字典的项for item in dicitonaryName.items(): print.(item) 遍历字典的key-valuefor item，value in adict.items(): print(item, value) 1234567891011121314# 遍历keyfor key in d: print '&#123;0&#125;:&#123;1&#125;'.format(key, d[key])print \"--------------------------------------\" keys = d.keys()print type(keys)print keysprint \"--------------------------------------\"for k, v in d.items(): print '&#123;0&#125;:&#123;1&#125;'.format(k, v) 1:one 2:two three:333 3:3 -------------------------------------- &lt;type &#39;list&#39;&gt; [1, 2, &#39;three&#39;, &#39;3&#39;] -------------------------------------- 1:one 2:two three:333 3:3 12 True True set集合没有重复元素的数组，能够自动去重 12345# 自动去重mySet = set([1, 2, 2, 3, 'a'])print mySetmySet = set((1, 2, 2, 3, 'a'))print mySet set([&#39;a&#39;, 1, 2, 3]) set([&#39;a&#39;, 1, 2, 3]) 12345# 添加元素mySet.add(\"China\") # 添加单个元素print mySetmySet.update([11, 22]) # 添加数组print mySet set([&#39;a&#39;, 1, 2, 3, 11, &#39;China&#39;, 22]) set([&#39;a&#39;, 1, 2, 3, 11, &#39;China&#39;, 22]) 123456# 删除元素mySet = set([1, 2, 2, 3, 'China'])mySet.remove(2)print mySetmySet.remove('China')print mySet set([1, 3, &#39;China&#39;]) set([1, 3]) 123# 遍历for i in mySet: print i a 1 2 3 123# 判断元素是否存在print 1 in mySetprint 5 not in mySet True True 12345678910111213141516# 求并集和交集set0 = set([1, 2, 3, 4])set1 = set([2, 3, 4, 5])print \"-------------------并集-------------------\"print set0.union(set1)print set0 | set1print \"-------------------交集-------------------\"print set0.intersection(set1)print set0 &amp; set1print \"-------------------差集-------------------\"print set0.difference(set1)print set0 - set1print \"-------------------对称差-------------------\"# (A | B) - (A &amp; B)，去掉相同的部分print set0 ^ set1print set0.symmetric_difference(set1) -------------------并集------------------- set([1, 2, 3, 4, 5]) set([1, 2, 3, 4, 5]) -------------------交集------------------- set([2, 3, 4]) set([2, 3, 4]) -------------------差集------------------- set([1]) set([1]) -------------------对称差------------------- set([1, 5]) set([1, 5]) 切片123456789101112131415lst = range(10)print lstprint \"--------------------------------------\"#[start:end:step]# start缺省为0，end缺省为末尾，step缺省为1print lst[::]print lst[2:5]print lst[5:]print lst[0:10:3]print lst[::-1] # 快速反转print lst[:-1:]print lst[-3:-1]print lst[-1:-3:-1]print \"--------------------------------------\"print lst # 切片不会改变原数组 [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] -------------------------------------- [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] [2, 3, 4] [5, 6, 7, 8, 9] [0, 3, 6, 9] [9, 8, 7, 6, 5, 4, 3, 2, 1, 0] [0, 1, 2, 3, 4, 5, 6, 7, 8] [7, 8] [9, 8] -------------------------------------- [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 列表推导Python 3.x支持dict和set的列表推导。 12lst = [0] * 10print lst [0, 0, 0, 0, 0, 0, 0, 0, 0, 0] 12lst = [i * 10 for i in range(10)]print lst [0, 10, 20, 30, 40, 50, 60, 70, 80, 90] 123456789101112131415# 注意有坑# 第一维的*3是复制# 第二维的*3是引用，即对第一行引用了三次，浅拷贝lst_2d = [ [0] * 3 ] * 3print lst_2dlst_2d[0][0] = 22print lst_2d # 坑print \"--------------------------------------\"# 填坑lst_2d = [ [0] * 3 for i in range(3)]print lst_2dlst_2d[0][0] = 22print lst_2d [[0, 0, 0], [0, 0, 0], [0, 0, 0]] [[22, 0, 0], [22, 0, 0], [22, 0, 0]] -------------------------------------- [[0, 0, 0], [0, 0, 0], [0, 0, 0]] [[22, 0, 0], [0, 0, 0], [0, 0, 0]] 生成器 用于解决惰性计算。用到时才计算，用不到就不计算 问题的提出 创建一个巨大的列表而仅仅需要访问其中少量几个元素 如果列表元素可以按照某种算法推算出来，是否可以在循环的过程中不断推算出后续的元素？这样就不必创建完整的list，从而节省大量的空间。 构造生成器： 列表推导时用()替换[] 使用yield 遍历： 使用next或者for循环 12345678# 平方表# 方法1：必须先计算0-10000的平方，需要大量耗时squareTable = []for i in range(10000): squareTable.append(i ** 2)for i in range(10): print squareTable[i], 0 1 4 9 16 25 36 49 64 81 12345678# 方法2：# 先定义一个生成器，无需耗费时间计算0-10000的平方squareTableGenerator = (x ** 2 for x in range(1000))print type(squareTableGenerator)# 调用时再计算for i in range(10): print next(squareTableGenerator), &lt;type &#39;generator&#39;&gt; 0 1 4 9 16 25 36 49 64 81 1234567891011121314151617181920212223242526272829def fib(limit): n, a, b = 0, 0, 1 while n &lt; limit: yield b a, b = b, a + b n += 1import tracebackf = fib(5)print(type(f))print(next(f))print(next(f))print(next(f))print(next(f))print(next(f))print \"--------------------------------------\"for i in fib(5): print(i)print \"--------------------------------------\" try: print(next(f))except StopIteration: traceback.print_exc() &lt;type &#39;generator&#39;&gt; 1 1 2 3 5 -------------------------------------- 1 1 2 3 5 -------------------------------------- Traceback (most recent call last): File &quot;&lt;ipython-input-48-5692bab5785c&gt;&quot;, line 27, in &lt;module&gt; print(next(f)) StopIteration 迭代器 可以直接作用于for循环的对象统称为可迭代对象Iterable 可以被next()函数调用并不断返回下一个值的对象称为迭代器Iterator 集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。 123456789101112131415from collections import Iterablefrom collections import Iterator# 判断是不是可迭代# 可迭代的都可以用for来循环print isinstance([], Iterable)print isinstance(&#123;&#125;, Iterable)print isinstance(123, Iterable)print isinstance('', Iterable)g = (x for x in range(10))print type(g)print isinstance(g, Iterable)for i in g: print i, True True False True &lt;type &#39;generator&#39;&gt; True 0 1 2 3 4 5 6 7 8 9 123456# 判断是不是迭代器print isinstance([], Iterator)# 生成器也是迭代器g = (x for x in range(10))print isinstance(g, Iterator) False True","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://helloliangxw.com/categories/Python基础/"}],"tags":[]},{"title":"Python变量与类型","slug":"Python变量与类型","date":"2017-04-19T09:30:00.000Z","updated":"2017-04-22T01:49:48.312Z","comments":true,"path":"2017/04/19/Python变量与类型/","link":"","permalink":"http://helloliangxw.com/2017/04/19/Python变量与类型/","excerpt":"","text":"变量命名规则 大小写字母、数字和下划线的组合，但首字母只能是大小写字母或下划线，不能使用空格。 中文等非字母符号也可以作为名字。 以下是合法命名的标识符：1234python_is_goodpython_is_not_good_is_it_a_question_ python语言 使用？显示变量信息变量前或后增加’?’将显示一些通用信息，包括函数对应的源代码。 12a = [1, 2, 3, '4']a? 123456Type: listString form: [1, 2, 3, '4']Length: 4Docstring: list() -&gt; new empty listlist(iterable) -&gt; new list initialized from iterable's items 赋值同步赋值：123456# 先运算右侧Ｎ个表达式，然后同时将表达式结果赋给左侧a, b, c = 1, 2, 3# 交换a和b的值x = 0y = 1x, y = y, x 连续赋值：12# 从右到左依次赋值a = b = c = 2 类型数字三种基本的数字类型： 整数 浮点数 复数 整数Python中整数没有取值范围的限制。 2进制：0b 0B开头8进制：0o 0O16进制：0x 0X 浮点数产看当前计算机浮点数的精度： 12import sysprint(sys.float_info) sys.float_info(max=1.7976931348623157e+308, max_exp=1024, max_10_exp=308, min=2.2250738585072014e-308, min_exp=-1021, min_10_exp=-307, dig=15, mant_dig=53, epsilon=2.220446049250313e-16, radix=2, rounds=1) 复数a+bj，虚数部分用j或J表示 123z = 2 + 3.5jprint(\"实数部分：\", z.real)print(\"虚数部分：\", z.imag) 实数部分： 2.0 虚数部分： 3.5 三种类型的转换使用int(), float(), complex()进行三者的转换整数和浮点数可以相互转换，而复数不能转换成整数或者浮点数 123456n = 4f = 3.5z = 1 + 5Jprint(float(n), ' ', complex(n))print(int(f), ' ', complex(f)) 4.0 (4+0j) 3 (3.5+0j) 123# 出错# print(int(z))# print(float(z)) 常用运算 运算符 说明 + - * / 加 减 乘 除 // 向下取整 % 求余 x**y, pow(x, y) 幂运算 divmod(x, y) (x//y, x%y) 字符串字符串就是一个字符序列，索引从0开始，支持负数索引。 123456# 字符串不能被修改s='abc'try : s[0]='x'except TypeError: print(\"Stop!\") Stop! 12345# 关于单引号和双引号s0=\"a'b'c\"s1='a\\'b\\'c'print(s0)print(s1) a&#39;b&#39;c a&#39;b&#39;c 12345678# 多行字符s0=\"hello+\" \\\"world\"s1=\"\"\"hello+world\"\"\"print(s0)print(\"--------------------------------------\")print(s1) hello+world -------------------------------------- hello+ world 12# 比较大小print('abc' &lt; 'ab') False 12345# 判断空字符串# None是空指针，空字符串在内存中是分配了空间的# 空字符串等价于Falseif not '': print ('is empty') is empty 12345678910# 常用判断print('abc'.startswith('a')) # 判断字符串开头print('def'.endswith('ef')) # 判断字符串结尾print('123abc'.isalnum()) # 是否全是字母和数字，并至少有一个字符。print('abc'.isalpha()) # 是否全是字母，并至少有一个字符。print('123'.isdigit()) # 是否全是数字，并至少有一个字符。print(' '.isspace()) # 是否全是空白字符，并至少有一个字符。print('abc'.islower()) # 字母是否全是小写print('ABC'.isupper()) # 字母是否全是大写print('Abc'.istitle()) # 首字母是否大写 True True True True True True True True True 常用方法： 方法 说明 s+t 字符串拼接 s**n 字符串重复n倍 len(s) 字符串s的长度 str(n) 数字n转字符串 int(s[, base]) 将字符串s转换为base进制的整数（默认为10进制） s.upper() 小写转大写 s.lower() 大写转小写 s.capitalize() 首字母大写 s.find(‘t’) 在字符串s中找到字符串t第一次出现的位置 s.strip() s.lstrip() s.rstrip() 去掉字符串s两端/左端/右端的空格 s.replace(‘a’, ‘A’) 将s中的字符a替换为A s.split(‘t’) 将s按照字符t分割 s.splitlines() 将s按行分割，等同于s.split(‘\\n’) s.join(list) 在列表元素之间以字符串s拼接 list(s) 将字符串s转换为字符列表 for i in s: 字符串迭代 字符串的格式化 方法1，使用“%”，类似于C语言； 方法2，使用format()。 Python推荐使用第二种。 槽和参数的顺序 当需要输出大括号时，用\\( \\{\\{ \\)表示\\(\\{ \\)，用\\(\\}\\}\\)表示\\(\\}\\)。 1print(\"&#123;&#123;&#123;&#125;的版本为&#123;&#125;&#125;&#125;\".format(\"python\", \"2.7\")) {python的版本为2.7} 格式控制信息槽的内部样式为：{&lt;参数序号&gt;: &lt;格式控制标记&gt;}其中，格式控制标记用来控制参数显示时的格式： 宽度和填充123456s = 'Python'print(\"&#123;0:30&#125;\".format(s))print(\"&#123;0:&gt;30&#125;\".format(s))print(\"&#123;0:*^30&#125;\".format(s))print(\"&#123;0:3&#125;\".format(s)) Python Python ************Python************ Python 千位分隔符12345n = 1234567890f = 12345.7890print(\"&#123;0:-^20,&#125;\".format(n))print(\"&#123;0:-^20&#125;\".format(n))print(\"&#123;0:-^20,&#125;\".format(f)) ---1,234,567,890---- -----1234567890----- -----12,345.789----- 精度123print(\"&#123;0:.2f&#125;\".format(f))print(\"&#123;0:H^20,.3f&#125;\".format(n))print(\"&#123;0:.4&#125;\".format(s)) 12345.79 H1,234,567,890.000HH Pyth 类型 b：整数的二进制形式 c：整数的Unicode字符 d：整数的十进制形式 o：整数的八进制形式 x：整数的小写十六进制形式 X：整数的大写十六进制形式 1print(\"&#123;0:b&#125;,&#123;0:c&#125;,&#123;0:d&#125;,&#123;0:o&#125;,&#123;0:x&#125;,&#123;0:X&#125;\".format(425)) 110101001,Ʃ,425,651,1a9,1A9 e: 浮点数对应的小写字母e的指数形式 E：浮点数对应的大写字母E的指数形式 f：浮点数的标准浮点形式 %：浮点数的百分形式 12print(\"&#123;0:e&#125;,&#123;0:E&#125;,&#123;0:f&#125;,&#123;0:%&#125;\".format(3.14))print(\"&#123;0:.2e&#125;,&#123;0:.2E&#125;,&#123;0:.2f&#125;,&#123;0:.2%&#125;\".format(3.14)) 3.140000e+00,3.140000E+00,3.140000,314.000000% 3.14e+00,3.14E+00,3.14,314.00%","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://helloliangxw.com/categories/Python基础/"}],"tags":[]},{"title":"Python文件与目录操作","slug":"Python文件与目录操作","date":"2017-04-19T08:49:00.000Z","updated":"2017-04-22T04:11:06.531Z","comments":true,"path":"2017/04/19/Python文件与目录操作/","link":"","permalink":"http://helloliangxw.com/2017/04/19/Python文件与目录操作/","excerpt":"","text":"常用文件编码ASCII码 标准化字符集 每个ASCII码以1个字节、7个二进制位（第一个二进制位为0）编码储存 从0到数字127代表不同的常用符号 例如大写A的ASCII码是65，小写a则是97。 Unicode 跨语言、跨平台进行文本转换和处理 对每种语言中字符设定统一且唯一的二进制编码 每个字符两个字节长 65536 个字符的编码空间 “严”：Unicode的十六进制数为4E25 UTF-8编码 可变长度（1个字节至4个字节）的Unicode的实现方式 “严”：十六进制数为E4B8A5 GBK编码 双字节编码 文本文件读写直接读入1234567891011121314file1 = open(\"input.txt\") file2 = open(\"output.txt\",\"w\") while True: line = file1.readline() #这里可以进行逻辑处理 file2.write(line) if not line: break #记住文件处理完，关闭是个好习惯 file1.close() file2.close() 读写模式： 打开模式 说明 r 只读。如果文件不存在，则输出错误 w 为只写（如果文件不存在，则自动创建文件） a 表示附加到文件末尾 rb 只读二进制文件。如果文件不存在，则输出错误 wb 只写二进制文件，如果文件不存在，则自动创建文件。 ab 附加到二进制文件末尾 r+ 读写 常用模式如:rb,wb,r+b等等。 读文件有3种方法： read() 将文本文件所有行读到一个字符串中 readline() 一行一行的读。 优点：可以在读行过程中跳过特定行。 readlines() 将文本文件中所有行读到一个list中，文本文件每一行是list的一个元素。 文件迭代器1234file2 = open(\"output.txt\",\"w\") for line in open(\"input.txt\"): #这里可以进行逻辑处理 file2.write(line) 上下文管理器12345678910111213141516171819# with.open自带关闭文本的功能with open('somefile.txt', 'r') as f: data = f.read() # loop整个文档with open('somefile.txt', 'r') as f: for line in f: # 处理每一行# 写入文本 with open('somefile.txt', 'w') as f: f.write(text1) f.write(text2) ... # 把要打印的line写入文件中 with open('somefile.txt', 'w') as f: print(line1, file = f) print(line2, file = f) 二进制文件读写Python默认读取的都是文本文件。要是想要读取二进制文件，需要把刚刚的r改成rb。 123f = open('EDC.jpg', 'rb')print(f.read())# 输出 '\\xff\\xd8\\xff\\xe1\\x00\\x18Exif\\x00\\x00...' # 十六进制表示的字节 简单说就是，任何非标准的文本文件（对于Python 3来说，标准是unicode），你就需要用二进制读入这个文件，然后再用 .decode(&#39;...&#39;)的方法来解码这个二进制文件。 1234f = open('DegangGuo.txt', 'rb')# 读入郭德纲老师的作文, 但是郭老师用的是\"DeyunCode\"的繁体编码# 那么你读入以后，就需要用它来解码u = f.read().decode('DeyunCode') 目录操作在图形界面的操作系统下，这个很简单，就是右键/拖拽等等。但是在Python的代码内该怎么做呢？ 基本操作用Python内置的os模块直接调用操作系统提供的接口函数。 1234567import os# 查看操作系统的名字，如果是`posix`，说明系统是#nix族，如果是`nt`，就是Windows。os.name# 在操作系统中定义的环境变量，全部保存在os.environ这个列表中，可以直接查看os.environ# 当前工作目录os.getcwd() 操作文件与目录查看、创建和删除目录。 123456789# 返回当前目录的绝对路径print os.path.abspath('.')print os.getcwd()# 列出当前目录下的所有目录print [x for x in os.listdir('.') if os.path.isdir(x)]# 列出所有的py文件print [y for y in os.listdir('.') if os.path.isfile(y) and os.path.splitext(y)[1]=='.txt'] E:\\MyDocuments\\Jupyter E:\\MyDocuments\\Jupyter [&#39;.ipynb_checkpoints&#39;] [&#39;a.txt&#39;] 1234567891011121314# 创建目录# 首先把新目录的完整路径表示出来:myPath = os.path.join('.', 'Pictures')print myPath# 这里你得到的是一个字符串，代表了新的文件夹是这个位置：E:\\MyDocuments\\Jupyter\\Pictures# 自己也可以拼起来，但是怕不同操作系统下的区分符问题，最好是用OS接口# 使用mkdir创建：if not os.path.exists(myPath):# 判断目录是否存在 os.mkdir(myPath) # 删除目录os.rmdir(myPath) .\\Pictures 同样的道理，要拆分路径时，也不要直接去拆字符串 12345# 把一个路径拆分为两部分，第二部分总是最后级别的目录或文件名print (os.path.split('C:/Users/EDC/Pictures/AJiao.jpg'))# 得到文件扩展名print (os.path.splitext('C:/Users/EDC/Pictures/AJiao.jpg')) (&#39;C:/Users/EDC/Pictures&#39;, &#39;AJiao.jpg&#39;) (&#39;C:/Users/EDC/Pictures/AJiao&#39;, &#39;.jpg&#39;) 操作文件 12345# 文件重命名：os.rename('JAV-001.avi', '学习资料')# 删除文件os.remove('学习资料') shutil库尴尬的是。。复制文件并不存在于os里。。(⊙﹏⊙)原因是复制这个操作，不是由操作系统提供的系统调用。我们可以用上面的代码，读入一个文件，再写入一个文件，来达到复制的目的。当然，Python作为一个Glue Language，总有第三方库来帮我们stay lazy：Shutil就是其中一个。基本上可以看做是os的补充。这个库用起来比os爽很多。比较简单易用。它提供copyfile()方法，来复制你的文件。 12import shutil shutil.copyfile('/path/to/file', '/path/to/other/file') 序列化和反序列化什么是序列化？程序运行的过程中，所有变量都是在内存中操作的，程序一旦执行完毕退出后，变量占有的内存就被操作系统回收了。因此我们需要将某些数据持久化存储到磁盘中，下次运行的时候从磁盘中读取相关数据。我们将变量从内存中变成可以存储或传输的过程称之为序列化，在Python中叫做pickling，在其它语言中也称之为 serialization、marshaling、flattening等等，说的都是一个意思。 反之，则为反序列化，称之为unpickling，把变量内容从序列化的对象重新读取到内存中。 使用pickle实现序列化123456789101112131415161718192021222324252627282930313233343536# Python 2和Python 3里面的pickle不一样。# Python 2中cPickle和pickle是分开的，而Python 3中两者已经合并了# 为了保证2，3的和谐，可以用这个方法来保证import正确try: import cPickle as pickleexcept ImportError: import pickle# 此处定义一个dict字典对象d = dict(name='思聪', age=29, score=80)# 调用pickle的dumps函数进行序列化处理d2Pkl = pickle.dumps(d)print (d2Pkl)# 调用pickle的loads函数进行序列化处理pkl2D = pickle.loads(d2Pkl)print (pkl2D)print (\"----------------------------------------------------------------\")# 将内容序列化写入到file文件中# 定义和创建一个file文件对象，注意设定模式为wbf = open('dump.pkl', 'wb')pickle.dump(d, f)f.close() # 最后关闭掉文件资源# 从之前序列化的dump.pkl文件里边读取内容f = open('dump.pkl', 'rb') # 设定文件选项模式为rbd = pickle.load(f) # 调用load做反序列处理过程f.close() # 关闭文件资源print(d)print('name is %s' % d['name']) (dp1 S&#39;age&#39; p2 I29 sS&#39;score&#39; p3 I80 sS&#39;name&#39; p4 S&#39;\\xe6\\x80\\x9d\\xe8\\x81\\xaa&#39; p5 s. {&#39;age&#39;: 29, &#39;score&#39;: 80, &#39;name&#39;: &#39;\\xe6\\x80\\x9d\\xe8\\x81\\xaa&#39;} ----------------------------------------------------- {&#39;age&#39;: 29, &#39;score&#39;: 80, &#39;name&#39;: &#39;\\xe6\\x80\\x9d\\xe8\\x81\\xaa&#39;} name is 思聪 使用JSON实现序列化Python的数据结构跟Json有非常完美的兼容： JSON类型 Python类型 {} dict [] list “string” ‘str’或者u’unicode’ 1234.56 int或float true/false True/False null None 如果你有一个比较结构化的数据想要序列化，并且想要人也能看得懂。那么你可以用JSON来做。 12345678910111213141516171819202122232425import json # 定义dict字典对象d = dict(name='小王', age=20, score=80)# 调用json的dumps函数进行json序列化处理d2Json = json.dumps(d)print d2Json# 调用json的loads函数进行反序列化处理json2D = json.loads(d2Json)print json2Dprint (\"======================================================\")# 序列化到文件中f = open('dump.json', 'w') # 设定文件选项模式为wjson.dump(d,f)f.close# 从文件中反序列化f = open('dump.json', 'r')d = json.load(f)f.closeprint dprint d['name'] {&quot;age&quot;: 20, &quot;score&quot;: 80, &quot;name&quot;: &quot;\\u5c0f\\u738b&quot;} {u&#39;age&#39;: 20, u&#39;score&#39;: 80, u&#39;name&#39;: u&#39;\\u5c0f\\u738b&#39;} ====================================================== {u&#39;age&#39;: 20, u&#39;score&#39;: 80, u&#39;name&#39;: u&#39;\\u5c0f\\u738b&#39;} 小王","categories":[{"name":"Python基础","slug":"Python基础","permalink":"http://helloliangxw.com/categories/Python基础/"}],"tags":[]},{"title":"Python-模块-NumPy-代码碎片","slug":"Python-模块-NumPy-代码碎片","date":"2017-04-18T07:38:00.000Z","updated":"2017-04-20T01:30:36.739Z","comments":true,"path":"2017/04/18/Python-模块-NumPy-代码碎片/","link":"","permalink":"http://helloliangxw.com/2017/04/18/Python-模块-NumPy-代码碎片/","excerpt":"","text":"交换矩阵的其中两行123import numpy as npa = np.arange(25).reshape(5,5)print(a) [[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14] [15 16 17 18 19] [20 21 22 23 24]] 12a[[0,1]] = a[[1,0]]print (a) [[ 5 6 7 8 9] [ 0 1 2 3 4] [10 11 12 13 14] [15 16 17 18 19] [20 21 22 23 24]] 找出与给定值最接近的数123456789101112b = np.array([[0,2,4,5],[9,7,6,8]])(m, n) = b.shapeprint(b)x = 9.1index = np.abs(b-x).argmin()print(index)## 方法1print(b[int(index/n), index - n*int(index/n)])## 方法2print(b.flatten()[index]) [[0 2 4 5] [9 7 6 8]] 4 9 9 判断是否不全为01234z = np.random.randint(0,2,(3,10))print(z)not_all_zero = z.any(axis=0)print(is_zero) [[0 1 1 0 1 0 1 0 0 0] [1 1 0 1 0 0 1 0 0 0] [1 1 0 1 0 0 1 1 0 0]] [ True False True True True True True True True True] 判断是否没有01234z = np.random.randint(0,2,(3,10))print(z)has_zero = z.all(axis=0)print(has_zero) [[0 0 0 1 1 0 1 0 1 1] [0 0 1 1 0 0 0 0 1 0] [1 0 0 0 0 1 0 0 1 0]] [False False False False False False False False True False] meshgrid1234x,y = np.meshgrid(np.linspace(-1,1,6),np.linspace(-1,1,6))print(x)print(\"-------------\")print(y) [[-1. -0.6 -0.2 0.2 0.6 1. ] [-1. -0.6 -0.2 0.2 0.6 1. ] [-1. -0.6 -0.2 0.2 0.6 1. ] [-1. -0.6 -0.2 0.2 0.6 1. ] [-1. -0.6 -0.2 0.2 0.6 1. ] [-1. -0.6 -0.2 0.2 0.6 1. ]] ------------- [[-1. -1. -1. -1. -1. -1. ] [-0.6 -0.6 -0.6 -0.6 -0.6 -0.6] [-0.2 -0.2 -0.2 -0.2 -0.2 -0.2] [ 0.2 0.2 0.2 0.2 0.2 0.2] [ 0.6 0.6 0.6 0.6 0.6 0.6] [ 1. 1. 1. 1. 1. 1. ]] 12D = np.sqrt(x**2+y**2)print(D) [[ 1.41421356 1.16619038 1.0198039 1.0198039 1.16619038 1.41421356] [ 1.16619038 0.84852814 0.63245553 0.63245553 0.84852814 1.16619038] [ 1.0198039 0.63245553 0.28284271 0.28284271 0.63245553 1.0198039 ] [ 1.0198039 0.63245553 0.28284271 0.28284271 0.63245553 1.0198039 ] [ 1.16619038 0.84852814 0.63245553 0.63245553 0.84852814 1.16619038] [ 1.41421356 1.16619038 1.0198039 1.0198039 1.16619038 1.41421356]] 123sigma,mu = 1,0a = np.exp(-(D-mu)**2/(2*sigma**2))print(a) [[ 0.36787944 0.50661699 0.59452055 0.59452055 0.50661699 0.36787944] [ 0.50661699 0.69767633 0.81873075 0.81873075 0.69767633 0.50661699] [ 0.59452055 0.81873075 0.96078944 0.96078944 0.81873075 0.59452055] [ 0.59452055 0.81873075 0.96078944 0.96078944 0.81873075 0.59452055] [ 0.50661699 0.69767633 0.81873075 0.81873075 0.69767633 0.50661699] [ 0.36787944 0.50661699 0.59452055 0.59452055 0.50661699 0.36787944]]","categories":[{"name":"Python-模块","slug":"Python-模块","permalink":"http://helloliangxw.com/categories/Python-模块/"}],"tags":[]},{"title":"Python-模块-NumPy-常用函数","slug":"Python-模块-NumPy-常用函数","date":"2017-04-17T12:36:00.000Z","updated":"2017-04-20T02:19:51.488Z","comments":true,"path":"2017/04/17/Python-模块-NumPy-常用函数/","link":"","permalink":"http://helloliangxw.com/2017/04/17/Python-模块-NumPy-常用函数/","excerpt":"","text":"随机函数 函数 说明 rand(d0,d1,..,dn) 根据d0‐dn创建随机数数组，浮点数，[0,1)，均匀分布 randn(d0,d1,..,dn) 根据d0‐dn创建随机数数组，标准正态分布 randint(low[,high,shape]) 根据shape创建随机整数或整数数组，范围是[low, high) seed(s) 随机数种子，s是给定的种子值 1234import numpy as npa = np.random.rand(3, 4)print(a) [[ 0.19114922 0.7068554 0.97088057 0.22036382] [ 0.55174823 0.00680082 0.73785489 0.88970624] [ 0.45998671 0.13359651 0.83150316 0.19457805]] 12b = np.random.randn(3, 4)print(b) [[ 1.12238235 0.27006584 0.63285753 1.08344082] [ 0.75890063 -0.41283425 1.20569367 -0.6684051 ] [-0.9419934 0.40069505 -0.78798551 1.60365521]] 12c = np.random.randint(3, 10, (2, 3))print(c) [[6 5 7] [8 4 8]] 12345678# 相同的种子，随机数的值相同np.random.seed(10)d = np.random.randint(3, 10, (2, 3))print(d)np.random.seed(10)e = np.random.randint(3, 10, (2, 3))print(e) [[4 8 7] [3 4 6]] [[4 8 7] [3 4 6]] 函数 说明 shuffle(a) 根据数组a的第1轴进行随排列，改变数组a permutation(a) 根据数组a的第1轴产生一个新的乱序数组，不改变数组a choice(a[,size,replace,p]) 从一维数组a中以概率p抽取元素，形成size形状新数组，replace表示是否可以重用元素，默认为False 12345# a改变a = np.arange(18).reshape(6, 3)print(a)np.random.shuffle(a)print(a) [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11] [12 13 14] [15 16 17]] [[15 16 17] [ 0 1 2] [ 3 4 5] [12 13 14] [ 6 7 8] [ 9 10 11]] 123456# a不改变a = np.arange(18).reshape(6, 3)print(a)b = np.random.permutation(a)print(a)print(b) [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11] [12 13 14] [15 16 17]] [[ 0 1 2] [ 3 4 5] [ 6 7 8] [ 9 10 11] [12 13 14] [15 16 17]] [[ 0 1 2] [15 16 17] [ 6 7 8] [ 9 10 11] [ 3 4 5] [12 13 14]] 123a = np.arange(18)b = np.random.choice(a, (3, 4), True, p = a/np.sum(a))print(b) [[ 6 11 15 13] [ 7 16 6 9] [ 5 4 15 2]] 函数 说明 uniform(low,high,size) 产生具有均匀分布的数组,low起始值,high结束值,size形状 normal(loc,scale,size) 产生具有正态分布的数组,loc均值,scale标准差,size形状 poisson(lam,size) 产生具有泊松分布的数组,lam随机事件发生率,size形状 统计函数 函数 说明 sum(a, axis=None) 根据给定轴axis计算数组a相关元素之和，axis整数或元组 mean(a, axis=None) 根据给定轴axis计算数组a相关元素的期望，axis整数或元组 average(a,axis=None,weights=None) 根据给定轴axis计算数组a相关元素的加权平均值 std(a, axis=None) 根据给定轴axis计算数组a相关元素的标准差 var(a, axis=None) 根据给定轴axis计算数组a相关元素的方差 axis=None是统计函数的标配参数 12a = np.arange(15).reshape(3, 5)print(a) [[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14]] 1print(np.sum(a, axis=0)) [15 18 21 24 27] 1print(np.mean(a, axis=1)) [ 2. 7. 12.] 1234# axis = 0为列向# 以第2列为例# (1*10+6*5+11*1)/(10+5+1) = 3.1875print(np.average(a, axis = 0, weights = [10, 5, 1])) [ 2.1875 3.1875 4.1875 5.1875 6.1875] 1print(np.std(a), np.var(a)) 4.32049379894 18.6666666667 函数 说明 min(a) max(a) 计算数组a中元素的最小值、最大值 argmin(a) argmax(a) 计算数组a中元素最小值、最大值的降一维后下标 unravel_index(index, shape) 根据shape将一维下标index转换成多维下标 ptp(a) 计算数组a中元素最大值与最小值的差 median(a) 计算数组a中元素的中位数（中值） 12a = np.arange(15).reshape(3, 5)print(a) [[ 0 1 2 3 4] [ 5 6 7 8 9] [10 11 12 13 14]] 1print(np.max(a), np.min(a, axis = 0)) 14 [0 1 2 3 4] 1print(np.argmin(a, axis = 0), np.argmax(a, axis = 1), np.argmax(a)) [0 0 0 0 0] [4 4 4] 14 1print(np.unravel_index([14], (3, 5))) (array([2], dtype=int64), array([4], dtype=int64)) 1print(np.ptp(a)) 14 1print(np.median(a)) 7.0 梯度函数 函数 说明 np.gradient(f) 计算数组f中元素的梯度，当f为多维时，返回每个维度梯度 梯度：连续值之间的变化率，即斜率。XY坐标系中，连续三个X坐标对应的Y轴值为a、b、c，那么b的梯度是：(c‐a)/2 对于[a, b, c, d]而言，a的梯度为：(b-a)/1b的梯度为：(c-a)/2c的梯度为：(d-b)/2d的梯度为：(d-c)/1 12a = np.random.randint(0, 20, (5))print(a) [11 10 9 15 18] 1print(np.gradient(a)) [-1. -1. 2.5 4.5 3. ] 12a = np.random.randint(0, 20, (3, 5))print(a) [[16 7 11 17 14] [ 7 11 1 0 12] [ 5 4 7 18 12]] 12# 结果分别表示，第0维的梯度和第1维的梯度print(np.gradient(a)) [array([[ -9. , 4. , -10. , -17. , -2. ], [ -5.5, -1.5, -2. , 0.5, -1. ], [ -2. , -7. , 6. , 18. , 0. ]]), array([[ -9. , -2.5, 5. , 1.5, -3. ], [ 4. , -3. , -5.5, 5.5, 12. ], [ -1. , 1. , 7. , 2.5, -6. ]])]","categories":[{"name":"Python-模块","slug":"Python-模块","permalink":"http://helloliangxw.com/categories/Python-模块/"}],"tags":[]},{"title":"Python-模块-NumPy-数据存取","slug":"Python-模块-NumPy-数据存取","date":"2017-04-17T12:07:00.000Z","updated":"2017-04-20T02:20:00.475Z","comments":true,"path":"2017/04/17/Python-模块-NumPy-数据存取/","link":"","permalink":"http://helloliangxw.com/2017/04/17/Python-模块-NumPy-数据存取/","excerpt":"","text":"一维和二维数据的存取保存1np.savetxt(fname, array, fmt='%.18e', delimiter=None) fname文件、字符串或产生器，可以是.gz或.bz2的压缩文件 array存入文件的数组 fmt写入文件的格式，例如：%d %.2f %.18e delimiter分割字符串，默认是任何空格 1234import numpy as npa = np.arange(100).reshape(5, 20)np.savetxt('a.csv', a, fmt='%d', delimiter=',') 读取-loadtxt1np.loadtxt(fname, dtype=np.float, delimiter=None, unpack=False) fname文件、字符串或产生器，可以是.gz或.bz2的压缩文件 dtype数据类型，可选 delimiter分割字符串，默认是任何空格 unpack如果True，每一列将分别写入不同变量 12b = np.loadtxt('a.csv', dtype = np.float, delimiter=',')print(b) [[ 0. 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. 16. 17. 18. 19.] [ 20. 21. 22. 23. 24. 25. 26. 27. 28. 29. 30. 31. 32. 33. 34. 35. 36. 37. 38. 39.] [ 40. 41. 42. 43. 44. 45. 46. 47. 48. 49. 50. 51. 52. 53. 54. 55. 56. 57. 58. 59.] [ 60. 61. 62. 63. 64. 65. 66. 67. 68. 69. 70. 71. 72. 73. 74. 75. 76. 77. 78. 79.] [ 80. 81. 82. 83. 84. 85. 86. 87. 88. 89. 90. 91. 92. 93. 94. 95. 96. 97. 98. 99.]] 12b = np.loadtxt('a.csv', dtype = np.float, delimiter=',', unpack=True)print(b) [[ 0. 20. 40. 60. 80.] [ 1. 21. 41. 61. 81.] [ 2. 22. 42. 62. 82.] [ 3. 23. 43. 63. 83.] [ 4. 24. 44. 64. 84.] [ 5. 25. 45. 65. 85.] [ 6. 26. 46. 66. 86.] [ 7. 27. 47. 67. 87.] [ 8. 28. 48. 68. 88.] [ 9. 29. 49. 69. 89.] [ 10. 30. 50. 70. 90.] [ 11. 31. 51. 71. 91.] [ 12. 32. 52. 72. 92.] [ 13. 33. 53. 73. 93.] [ 14. 34. 54. 74. 94.] [ 15. 35. 55. 75. 95.] [ 16. 36. 56. 76. 96.] [ 17. 37. 57. 77. 97.] [ 18. 38. 58. 78. 98.] [ 19. 39. 59. 79. 99.]] 读取-genfromtxtnp.genfromtxt()和np.loadtxt()函数类似： 1np.genfromtxt(fname, delimiter=\"\", dtype=str, filling_values = [10]) 但是，np.genfromtxt()提供了对缺失值的处理。假设有一张有缺失值的csv的表： 1 2 - 5 - 6 - - 9 可以使用np.genfromtxt()对每一列的缺失值进行填充： 12345678import numpy as np# 对每一列填充不同的值a = np.genfromtxt('a_nan.csv', delimiter=',', dtype = np.float, filling_values=[10, 20, 30])print(a)# 所有的缺失值填充相同的值b = np.genfromtxt('a_nan.csv', delimiter=',', dtype = np.float, filling_values=999)print(b) [[ 1. 2. 30.] [ 5. 20. 6.] [ 10. 20. 9.]] [[ 1. 2. 999.] [ 5. 999. 6.] [ 999. 999. 9.]] 多维数据的存取保存1a.tofile(fname, sep='', format='%s') fname文件、字符串 sep数据分割字符串，如果是空串，写入文件为二进制 format写入数据的格式 12a = np.arange(18).reshape(3, 6)a.tofile('a.dat', sep = '', format = '%d') 读取1np.fromfile(fname, dtype=float, count=-1, sep='') fname文件、字符串 dtype读取的数据类型 count读入元素个数，‐1表示读入整个文件 sep数据分割字符串，如果是空串，读入文件为二进制 12b = np.fromfile('a.dat', dtype = np.int32, sep = '')print(b) [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17] 注意：a.tofile()和np.fromfile()需要配合使用，并且需要知道存入文件时数组的维度和元素类型。可以通过元数据文件来存储额外信息。 便捷文件存取保存：1np.save(fname, array) 或 np.savez(fname, array) fname文件名，以.npy为扩展名，压缩扩展名为.npz array数组变量 读取:1np.load(fname) fname文件名，以.npy为扩展名，压缩扩展名为.npz 1234a = np.arange(18).reshape(3, 6)np.save('a.npy', a)b = np.load('a.npy')print(b) [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11] [12 13 14 15 16 17]] 如果我们用文本方式打开a.npy文件：1234揘UMPY\u0001 F &#123;&apos;descr&apos;: &apos;&lt;i4&apos;, &apos;fortran_order&apos;: False, &apos;shape&apos;: (3, 6), &#125; \u0001 \u0002 \u0003 \u0004 \u0005 \u0006 \u0007 \b \u000e \u000f \u0010 \u0011 会发现，npy文件中保存了原来数组的大小和类型。","categories":[{"name":"Python-模块","slug":"Python-模块","permalink":"http://helloliangxw.com/categories/Python-模块/"}],"tags":[]},{"title":"Python-模块-NumPy-ndarry对象","slug":"Python-模块-NumPy-ndarry对象","date":"2017-04-17T11:27:00.000Z","updated":"2017-04-20T01:28:02.869Z","comments":true,"path":"2017/04/17/Python-模块-NumPy-ndarry对象/","link":"","permalink":"http://helloliangxw.com/2017/04/17/Python-模块-NumPy-ndarry对象/","excerpt":"","text":"N维数组对象ndarrayndarray对象的属性 属性 说明 .ndim 维度的数量 .shape ndarray对象的尺度，对于矩阵，n行m列 .size ndarray对象元素的个数，相当于.shape中n*m的值 .dtype ndarray对象的元素类型 .itemsize ndarray对象中每个元素的大小，以字节为单位 12345import numpy as np a = np.array([ [1, 2, 3], [4, 5, 6] ] )print(a)print(a.ndim, a.shape, a.size, a.dtype, a.itemsize) [[1 2 3] [4 5 6]] 2 (2, 3) 6 int32 4 元素类型 数据类型 说明 bool 布尔类型，True或False intc 与C语言中的int类型一致，一般是int32或int64 intp 用于索引的整数，与C语言中ssize_t一致，int32或int64 int8 字节长度的整数，取值：[‐128, 127] int16 16位长度的整数，取值：[‐32768, 32767] int32 32位长度的整数，取值：[‐2 31 , 2 31 ‐1] int64 64位长度的整数，取值：[‐2 63 , 2 63 ‐1] uint8 8位无符号整数，取值：[0, 255] uint16 16位无符号整数，取值：[0, 65535] uint32 32位无符号整数，取值：[0, 2 32 ‐1] uint64 32位无符号整数，取值：[0, 2 64 ‐1] float16 16位半精度浮点数：1位符号位，5位指数，10位尾数，(符号)尾数 \\(*10^{指数}\\) float32 32位半精度浮点数：1位符号位，8位指数，23位尾数 float64 64位半精度浮点数：1位符号位，11位指数，52位尾数 complex64 复数类型，实部和虚部都是32位浮点数 complex128 复数类型，实部和虚部都是64位浮点数 ndarray为什么要支持这么多种元素类型？ 科学计算涉及数据较多，对存储和性能都有较高要求 对元素类型精细定义，有助于NumPy合理使用存储空间并优化性能 对元素类型精细定义，有助于程序员对程序规模进行合理评估 ndarray的创建通过列表、元组等创建1234567a = np.array([1, 2, 3])# 列表和元组可以共同使用，只需要元素个数相同b = np.array([ [1, 2], (3, 4) ])c = np.array([20, 21], dtype = np.float)print(a, a.dtype)print(b, b.dtype)print(c, c.dtype) [1 2 3] int32 [[1 2] [3 4]] int32 [ 20. 21.] float64 当np.array()不指定dtype时，NumPy将根据数据情况关联一个dtype类型。 通过NumPy函数创建 函数 说明 np.arange(n) 类似range()函数，返回ndarray类型，元素从0到n‐1 np.ones(shape) 根据shape生成一个全1数组，shape是元组类型 np.zeros(shape) 根据shape生成一个全0数组，shape是元组类型 np.full(shape,val) 根据shape生成一个数组，每个元素值都是val np.eye(n) 创建一个正方的n*n单位矩阵，对角线为1，其余为0 12a = np.arange(12)print(a) [ 0 1 2 3 4 5 6 7 8 9 10 11] 12a = np.ones((2, 3))print(a) [[ 1. 1. 1.] [ 1. 1. 1.]] 12a = np.zeros((2, 3))print(a) [[ 0. 0. 0.] [ 0. 0. 0.]] 12a = np.full((2, 3), 21, dtype = np.float)print(a) [[ 21. 21. 21.] [ 21. 21. 21.]] 12a = np.eye(4)print(a) [[ 1. 0. 0. 0.] [ 0. 1. 0. 0.] [ 0. 0. 1. 0.] [ 0. 0. 0. 1.]] 函数 说明 np.linspace(start, end, n) 根据起止数据等间距地填充数据，形成长度为n的数组 np.concatenate((a, b)) 将两个或多个数组合并成一个新的数组 123# 每个元素之间的间距为(end-start)/(n-1)a = np.linspace(1, 10, 4)print(a) [ 1. 4. 7. 10.] 1234# endpoint为False时，表示end不在最后生成的数组中# 每个元素之间的间距为(end-start)/nb = np.linspace(1, 10, 4, endpoint = False)print(b) [ 1. 3.25 5.5 7.75] 12c = np.concatenate((a, b))print(c) [ 1. 4. 7. 10. 1. 2.75 4.5 6.25] 函数 说明 np.ones_like(a) 根据数组a的形状生成一个全1数组 np.zeros_like(a) 根据数组a的形状生成一个全0数组 np.full_like(a,val) 根据数组a的形状生成一个数组，每个元素值都是val 12a = np.ones((4, 4))print(a.shape) (4, 4) 12b = np.ones_like(a)print(b) [[ 1. 1. 1. 1.] [ 1. 1. 1. 1.] [ 1. 1. 1. 1.] [ 1. 1. 1. 1.]] 12b = np.zeros_like(a)print(b) [[ 0. 0. 0. 0.] [ 0. 0. 0. 0.] [ 0. 0. 0. 0.] [ 0. 0. 0. 0.]] 12b = np.full_like(a, 6)print(b) [[ 6. 6. 6. 6.] [ 6. 6. 6. 6.] [ 6. 6. 6. 6.] [ 6. 6. 6. 6.]] 通过复制已有数组1234a = np.arange(5)b = ac = a.view()d = a.copy() 区别： b = ab和a完全一样，改变b时a也跟着改变，是完全相同的对象 c = a.view()c是a的浅复制，c和a是不同的对象，但是改变c时a也跟着改变 d = a.copy()d是a的深复制，改变d时a不改变。推荐使用。 ndarray数组的变换维度变换 方法 说明 .reshape(shape) 不改变数组元素，返回一个shape形状的数组，原数组不变 .resize(shape) 与.reshape()功能一致，但修改原数组 .swapaxes(ax1,ax2) 将数组n个维度中两个维度进行调换 .flatten() .ravel() 对数组进行降维，返回折叠后的一维数组，原数组不变 .T 转置 123456# 三维数组，为层*行*列a = np.array([ [[1, 1, 1, 1], [2, 2, 2, 2], [3, 3, 3, 3]], [[4, 4, 4, 4], [5, 5, 5, 5], [6, 6, 6, 6]] ], dtype = np.int32)print(a) [[[1 1 1 1] [2 2 2 2] [3 3 3 3]] [[4 4 4 4] [5 5 5 5] [6 6 6 6]]] 123b = a.reshape((3, 8))print(b)print(a) [[1 1 1 1 2 2 2 2] [3 3 3 3 4 4 4 4] [5 5 5 5 6 6 6 6]] [[[1 1 1 1] [2 2 2 2] [3 3 3 3]] [[4 4 4 4] [5 5 5 5] [6 6 6 6]]] 12345# 修改原数组a.resize((3, 8))print(a)a.shape = (4, 6)print(a) [[1 1 1 1 2 2 2 2] [3 3 3 3 4 4 4 4] [5 5 5 5 6 6 6 6]] [[1 1 1 1 2 2] [2 2 3 3 3 3] [4 4 4 4 5 5] [5 5 6 6 6 6]] 12b = a.flatten()print(b) [1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6] 12b = a.ravel()print(b) [1 1 1 1 2 2 2 2 3 3 3 3 4 4 4 4 5 5 5 5 6 6 6 6] 12b = a.Tprint(b) [[1 2 4 5] [1 2 4 5] [1 3 4 6] [1 3 4 6] [2 3 5 6] [2 3 5 6]] 元素类型变换1print(a.dtype) int32 1234# astype()方法一定会创建新的数组（原始数据的一个拷贝），即使两个类型一致b = a.astype(np.float)print(b)print(b.dtype) [[ 1. 1. 1. 1. 2. 2. 2. 2.] [ 3. 3. 3. 3. 4. 4. 4. 4.] [ 5. 5. 5. 5. 6. 6. 6. 6.]] float64 向列表的转换1print(a) [[1 1 1 1 2 2 2 2] [3 3 3 3 4 4 4 4] [5 5 5 5 6 6 6 6]] 12print(a.tolist())print(type(a)) [[1, 1, 1, 1, 2, 2, 2, 2], [3, 3, 3, 3, 4, 4, 4, 4], [5, 5, 5, 5, 6, 6, 6, 6]] &lt;class &#39;numpy.ndarray&#39;&gt; ndarray数组的索引与切片 索引获取数组中特定位置元素的过程 切片获取数组元素子集的过程 一维数组123import numpy as npa = np.linspace(0, 51, 18)print(a) [ 0. 3. 6. 9. 12. 15. 18. 21. 24. 27. 30. 33. 36. 39. 42. 45. 48. 51.] 123# 使用特定的值print(a[2])print(a[-2]) 6.0 48.0 12345# 使用切片# 起始编号:终止编号(不含):步长print(a[0:6:2])print(a[10:2:-2])print(a[::3]) [ 0. 6. 12.] [ 30. 24. 18. 12.] [ 0. 9. 18. 27. 36. 45.] 123# 使用列表print(a[[0, 3, 6]])print(a[range(3)]) [ 0. 9. 18.] [ 0. 3. 6.] 多维数组12a = np.arange(24).reshape((2, 3, 4))print(a) [[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[12 13 14 15] [16 17 18 19] [20 21 22 23]]] 1234# 每个维度都使用特定的值# 第一个维度为层向，第二个维度为行向print(a[1, 2, 3])print(a[-2, 2, -3]) 23 9 12# 使用切片print(a[:, 1, 3]) [ 7 19] 1print(a[:, 1:3, 3]) [[ 7 11] [19 23]] 1print(a[:, 1:3, :]) [[[ 4 5 6 7] [ 8 9 10 11]] [[16 17 18 19] [20 21 22 23]]] 1print(a[:, :, ::2]) [[[ 0 2] [ 4 6] [ 8 10]] [[12 14] [16 18] [20 22]]] 123# 使用列表# 分别取a[1, 0, 0] a[0, 0, 2] a[1, 1, 3]的值print(a[[1,0,1],[0,0,1],[0,2,3]]) [12 2 19] 12345678data = np.sin(np.arange(20)).reshape(5,4)print(data)# 找出每一列最大的值所在的索引ind = data.argmax(axis=0)print(ind)# 根据索引找出最大的值data_max = data[ind, range(data.shape[1])]print (data_max) [[ 0. 0.84147098 0.90929743 0.14112001] [-0.7568025 -0.95892427 -0.2794155 0.6569866 ] [ 0.98935825 0.41211849 -0.54402111 -0.99999021] [-0.53657292 0.42016704 0.99060736 0.65028784] [-0.28790332 -0.96139749 -0.75098725 0.14987721]] [2 0 3 1] [ 0.98935825 0.84147098 0.99060736 0.6569866 ] ndarray数组的运算NumPy一元函数 函数 说明 np.abs(x) np.fabs(x) 计算数组各元素的绝对值 np.sqrt(x) 计算数组各元素的平方根 np.square(x) 计算数组各元素的平方 np.log(x) np.log10(x) np.log2(x) 计算数组各元素以e为底、以10为底、以2为底的对数 np.ceil(x) np.floor(x) 计算数组各元素的ceiling值 或 floor值 np.rint(x) 计算数组各元素的四舍五入值 np.modf(x) 将数组各元素的小数和整数部分以两个独立数组形式返回 np.cos(x) np.sin(x) np.tan(x) 计算数组各元素的三角函数 np.exp(x) 计算数组各元素的指数值 np.sign(x) 计算数组各元素的符号值，1(+), 0, ‐1(‐) np.sort(x) 对数组进行排序 np.tile(x, (m, n)) 将数组复制成(m,n)份 12345import numpy as npa = np.arange(4).reshape(2, 2)b = np.arange(4, 0, -1).reshape(2, 2)print(a)print(b) [[0 1] [2 3]] [[4 3] [2 1]] 1print(a/2) [[ 0. 0.5] [ 1. 1.5]] 1print(np.sort(b, axis = 0)) [[2 1] [4 3]] 1print(np.tile(a, (2, 2))) [[0 1 0 1] [2 3 2 3] [0 1 0 1] [2 3 2 3]] NumPy二元函数 函数 说明 + ‐ * / ** 两个数组各元素进行对应运算 np.dot(x,y) 矩阵相乘，即x.dot(y) np.maximum(x,y) np.minimum(x,y) 元素级的最大值/最小值计算 np.fmax(x,y) np.fmin(x,y) 同上 np.mod(x,y) 元素级的模运算 np.copysign(x,y) 将数组y中各元素值的符号赋值给数组x对应元素 &gt;, &lt;, &gt;=, &lt;=, ==, != 算术比较，产生布尔型数组 np.vstack((a,b)) np.hstack((a,b)) 数组拼接 np.hsplit(a,n) np.vsplit(a,n) 将数组平均切成n份 12345import numpy as npa = np.arange(4).reshape(2, 2)b = np.arange(4, 0, -1).reshape(2, 2)print(a)print(b) [[0 1] [2 3]] [[4 3] [2 1]] 123print(a-b)print(a-1)print(b**2) [[-4 -2] [ 0 2]] [[-1 0] [ 1 2]] [[16 9] [ 4 1]] 123con = (b&lt;2) | (b&gt;3)print(con)print(b[con]) [[ True False] [False True]] [4 1] 123456789matrix = np.array([ [5, 10, 15], [20, 25, 30], [35, 40, 45] ])con = (matrix[:,1] == 25)print(con)# 保留第2行print(matrix[con, :]) [False True False] [[20 25 30]] 1print(np.dot(a, b)) [[ 2 1] [14 9]] 12print(np.maximum(a, b))print(np.fmax(a, b)) [[4 3] [2 3]] [[4 3] [2 3]] 1print(np.mod(a, b)) [[0 1] [0 0]] 12print(np.hstack((a, b)))print(np.vstack((a, b))) [[0 1 4 3] [2 3 2 1]] [[0 1] [2 3] [4 3] [2 1]] 12a = np.arange(24).reshape(2, 12)print(a) [[ 0 1 2 3 4 5 6 7 8 9 10 11] [12 13 14 15 16 17 18 19 20 21 22 23]] 12# 将a平均切割成4份print(np.hsplit(a, 4)) [array([[ 0, 1, 2], [12, 13, 14]]), array([[ 3, 4, 5], [15, 16, 17]]), array([[ 6, 7, 8], [18, 19, 20]]), array([[ 9, 10, 11], [21, 22, 23]])] 12# 在第2列和第5列之前分别切一刀print(np.hsplit(a, (2, 5))) [array([[ 0, 1], [12, 13]]), array([[ 2, 3, 4], [14, 15, 16]]), array([[ 5, 6, 7, 8, 9, 10, 11], [17, 18, 19, 20, 21, 22, 23]])] ndarray方法 方法 说明 .argsort() 排序后的下标索引 .argmax() .argmin() 最大值和最小值的下标索引 12345a = np.array([2, 5, 6, 2, 3])print(a)print(a.argmax())print(a.argmin())print(a.argsort()) [2 5 6 2 3] 2 0 [0 3 4 1 2]","categories":[{"name":"Python-模块","slug":"Python-模块","permalink":"http://helloliangxw.com/categories/Python-模块/"}],"tags":[]}]}